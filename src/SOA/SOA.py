# -*- coding: utf-8 -*-
"""Untitled37 (2).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZLOXFIRVSQQgCYyrIzICT672eVPf07jK
"""

# -*- coding: utf-8 -*-
# Тележка + перевёрнутый маятник
  #режим "пастушья собака"

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import HTML, display
import ipywidgets as widgets

# ---------- ПАРАМЕТРЫ СИСТЕМЫ ----------
M = 1.0     # масса тележки
m = 0.2     # масса маятника
L = 1.0     # длина маятника
g = 9.81
mu = 0.1    # трение тележки

def cart_pole_dynamics(state, F):
    """
    state = [x, x_dot, theta, theta_dot]
    F — сила на тележку
    """
    x, x_dot, theta, theta_dot = state
    sin_th = np.sin(theta)
    cos_th = np.cos(theta)

    total_mass = M + m
    temp = (F + m * L * theta_dot**2 * sin_th - mu * x_dot) / total_mass

    theta_ddot = (g * sin_th - cos_th * temp) / (
        L * (4.0/3.0 - m * cos_th**2 / total_mass)
    )
    x_ddot = temp - m * L * theta_ddot * cos_th / total_mass

    return np.array([x_dot, x_ddot, theta_dot, theta_ddot])


def angle_wrap(theta):
    """Привести угол к (-pi, pi)."""
    return (theta + np.pi) % (2*np.pi) - np.pi


# ---------- КОНТРОЛЛЕРЫ ----------
def controller_PD(x, x_dot, theta, theta_dot,
                  x_ref, theta_ref,
                  Kp_theta, Kd_theta, Kp_x, Kd_x, F_max):
    e_theta = angle_wrap(theta_ref - theta)
    e_x = x_ref - x
    F = (Kp_theta * e_theta +
         Kd_theta * (0.0 - theta_dot) +
         Kp_x * e_x +
         Kd_x * (0.0 - x_dot))
    return np.clip(F, -F_max, F_max)


def controller_DOG(x, x_dot, theta, theta_dot,
                   x_ref, theta_ref,
                   Kp_theta, Kd_theta, Kp_x, Kd_x, F_max):
    """
    Алгоритм "пастушьей собаки":
    нелинейное насыщённое управление через tanh.
    """
    e_theta = angle_wrap(theta_ref - theta)
    e_x = x_ref - x
    F = (Kp_theta * np.tanh(e_theta) +
         Kd_theta * np.tanh(-theta_dot) +
         Kp_x * np.tanh(e_x) +
         Kd_x * np.tanh(-x_dot))
    return np.clip(F, -F_max, F_max)


# ---------- СИМУЛЯЦИЯ + ВИЗУАЛИЗАЦИЯ ----------
def simulate_and_plot_cart_pole(
    mode='PD',          # 'Off' / 'PD' / 'Dog'
    x_ref=0.0,
    theta_ref_deg=0.0,
    x0=0.0,
    xdot0=0.0,
    theta0_deg=10.0,
    thetadot0=0.0,
    Kp_theta=60.0,
    Kd_theta=10.0,
    Kp_x=2.0,
    Kd_x=4.0,
    F_max=50.0,
    T=10.0,
    dt=0.01,
    show_animation=True
):
    plt.close('all')

    theta_ref = np.deg2rad(theta_ref_deg)
    theta0 = np.deg2rad(theta0_deg)

    N = int(T / dt)
    t = np.linspace(0, T, N)

    state = np.zeros((N, 4))
    state[0] = [x0, xdot0, theta0, thetadot0]
    F_arr = np.zeros(N)

    for k in range(N - 1):
        x, x_dot, theta, theta_dot = state[k]

        if mode == 'Off':
            F = 0.0
        elif mode == 'PD':
            F = controller_PD(
                x, x_dot, theta, theta_dot,
                x_ref, theta_ref,
                Kp_theta, Kd_theta, Kp_x, Kd_x, F_max
            )
        elif mode == 'Dog':
            F = controller_DOG(
                x, x_dot, theta, theta_dot,
                x_ref, theta_ref,
                Kp_theta, Kd_theta, Kp_x, Kd_x, F_max
            )
        else:
            F = 0.0

        F_arr[k] = F
        deriv = cart_pole_dynamics(state[k], F)
        state[k+1] = state[k] + dt * deriv

    x = state[:, 0]
    theta = state[:, 2]
    theta_dot = state[:, 3]

    # координаты груза (для траектории)
    bob_x_all = x + L * np.sin(theta)
    bob_y_all = 0 + L * np.cos(theta)

    # ---------- ГРАФИКИ ----------
    fig1, ax = plt.subplots(3, 1, figsize=(8, 8), sharex=True)

    ax[0].plot(t, x, label='x(t)')
    ax[0].axhline(x_ref, linestyle='--', color='k', label='x_ref')
    ax[0].set_ylabel("Положение тележки, м")
    ax[0].grid(True)
    ax[0].legend()

    ax[1].plot(t, np.rad2deg(theta), label='θ(t)')
    ax[1].axhline(theta_ref_deg, linestyle='--', color='k', label='θ_ref')
    ax[1].set_ylabel("Угол маятника, °")
    ax[1].grid(True)
    ax[1].legend()

    ax[2].plot(t, F_arr, label='F(t)')
    ax[2].axhline(F_max, color='r', linestyle='--', linewidth=0.8, label='F_max')
    ax[2].axhline(-F_max, color='r', linestyle='--', linewidth=0.8)
    ax[2].set_ylabel("Сила, Н")
    ax[2].set_xlabel("Время, с")
    ax[2].grid(True)
    ax[2].legend()

    fig1.suptitle(f"Тележка с перевёрнутым маятником, режим: {mode}")
    plt.tight_layout()
    plt.show()

    # ---------- АНИМАЦИЯ ----------
    if show_animation:
        fig, ax = plt.subplots(figsize=(9, 5))

        x_min = np.min(x) - 2.0
        x_max = np.max(x) + 2.0
        if x_min == x_max:
            x_min, x_max = -5, 5

        ax.set_xlim(x_min, x_max)
        ax.set_ylim(-2.5, 3.5)
        ax.set_xlabel("Положение (м)")
        ax.set_ylabel("Высота (м)")
        ax.set_title("Перевернутый маятник на тележке ")
        ax.grid(True, linestyle=":", linewidth=0.8)
        ax.axhline(0, color="black", linewidth=1)


        cart_w, cart_h = 4.2, 1.5
        cart = plt.Rectangle((0, 0), cart_w, cart_h,
                             fc="none", ec="blue", linewidth=3)
        ax.add_patch(cart)

        # маятник
        rod, = ax.plot([], [], lw=3, color='red')
        bob, = ax.plot([], [], 'o', color='red', markersize=10)

        # траектория груза
        traj, = ax.plot([], [], '-', color='red', linewidth=1, alpha=0.7)

        # подписи
        text_box1 = ax.text(
            x_min + 0.2, 3.2, "",
            fontsize=9, va="top",
            bbox=dict(boxstyle="round", facecolor="white", alpha=0.9)
        )
        text_box2 = ax.text(
            x_min + 0.2, 1.8, "",
            fontsize=9, va="top",
            bbox=dict(boxstyle="round", facecolor="white", alpha=0.9)
        )

        def init():
            rod.set_data([], [])
            bob.set_data([], [])
            traj.set_data([], [])
            text_box1.set_text("")
            text_box2.set_text("")
            return rod, bob, cart, traj, text_box1, text_box2

        step = max(1, int(0.01 / dt))
        frames = range(0, len(t), step)

        def update(i):
            xi, theta_i = x[i], theta[i]

            # тележка
            cart_x = xi - cart_w/2
            cart_y = 0 - cart_h/2
            cart.set_xy((cart_x, cart_y))

            # маятник
            px, py = xi, 0.0
            bx = bob_x_all[i]
            by = bob_y_all[i]

            rod.set_data([px, bx], [py, by])
            bob.set_data([bx], [by])

            # траектория груза
            traj.set_data(bob_x_all[:i+1], bob_y_all[:i+1])

            time_now = t[i]
            status = "СТАБИЛЬНО" if (abs(np.rad2deg(angle_wrap(theta_i))) < 15 and abs(theta_dot[i]) < 1.0) else "НЕСТАБИЛЬНО"

            text_box1.set_text(
                "Время: {:.2f} с\n"
                "Угол (к верх=0°): {:.1f}°\n"
                "Скорость угл.: {:.2f} рад/с".format(
                    time_now, np.rad2deg(theta_i), theta_dot[i]
                )
            )

            text_box2.set_text(
                "Позиция: {:.2f} м\n"
                "Скорость тележки: {:.2f} м/с\n"
                "Статус: {}".format(
                    xi, state[i,1], status
                )
            )

            return rod, bob, cart, traj, text_box1, text_box2

        anim = FuncAnimation(
            fig, update, init_func=init,
            frames=frames,
            interval=1000 * dt * step,
            blit=True
        )

        plt.close(fig)
        display(HTML(anim.to_jshtml()))


# ---------- ВИДЖЕТЫ ДЛЯ COLAB ----------

mode_widget = widgets.Dropdown(
    options=[('Off','Off'),
             ('PD','PD'),
             ('Dog (пастушья)','Dog')],
    value='Dog',
    description='Режим:'
)

x_ref_widget = widgets.FloatSlider(
    value=0.0, min=-5, max=5, step=0.1,
    description='x_ref:', continuous_update=False
)

theta_ref_widget = widgets.FloatSlider(
    value=0.0, min=-30, max=30, step=1,
    description='θ_ref (°):', continuous_update=False
)

x0_widget = widgets.FloatSlider(
    value=0.0, min=-3, max=3, step=0.1,
    description='x0:', continuous_update=False
)

xdot0_widget = widgets.FloatSlider(
    value=0.0, min=-5, max=5, step=0.1,
    description='ẋ0:', continuous_update=False
)

theta0_widget = widgets.FloatSlider(
    value=10.0, min=-60, max=60, step=1,
    description='θ0 (°):', continuous_update=False
)

thetadot0_widget = widgets.FloatSlider(
    value=0.0, min=-10, max=10, step=0.1,
    description='θ̇0:', continuous_update=False
)

Kp_theta_widget = widgets.FloatSlider(
    value=60.0, min=0, max=200, step=1,
    description='Kθ_p:', continuous_update=False
)

Kd_theta_widget = widgets.FloatSlider(
    value=10.0, min=0, max=50, step=0.5,
    description='Kθ_d:', continuous_update=False
)

Kp_x_widget = widgets.FloatSlider(
    value=2.0, min=0, max=20, step=0.2,
    description='Kx_p:', continuous_update=False
)

Kd_x_widget = widgets.FloatSlider(
    value=4.0, min=0, max=40, step=0.5,
    description='Kx_d:', continuous_update=False
)

F_max_widget = widgets.FloatSlider(
    value=50.0, min=5, max=200, step=5,
    description='F_max:', continuous_update=False
)

T_widget = widgets.FloatSlider(
    value=10.0, min=2, max=30, step=1,
    description='T (с):', continuous_update=False
)

dt_widget = widgets.FloatLogSlider(
    value=0.01, base=10, min=-3, max=-1,
    description='dt:', continuous_update=False
)

show_anim_widget = widgets.Checkbox(
    value=True, description='Анимация'
)

controls = widgets.VBox([
    mode_widget,
    widgets.HBox([x_ref_widget, theta_ref_widget]),
    widgets.HBox([x0_widget, xdot0_widget]),
    widgets.HBox([theta0_widget, thetadot0_widget]),
    widgets.HBox([Kp_theta_widget, Kd_theta_widget]),
    widgets.HBox([Kp_x_widget, Kd_x_widget]),
    widgets.HBox([F_max_widget, T_widget, dt_widget]),
    show_anim_widget
])

out = widgets.interactive_output(
    simulate_and_plot_cart_pole,
    dict(
        mode=mode_widget,
        x_ref=x_ref_widget,
        theta_ref_deg=theta_ref_widget,
        x0=x0_widget,
        xdot0=xdot0_widget,
        theta0_deg=theta0_widget,
        thetadot0=thetadot0_widget,
        Kp_theta=Kp_theta_widget,
        Kd_theta=Kd_theta_widget,
        Kp_x=Kp_x_widget,
        Kd_x=Kd_x_widget,
        F_max=F_max_widget,
        T=T_widget,
        dt=dt_widget,
        show_animation=show_anim_widget
    )
)

display(controls, out)

# -*- coding: utf-8 -*-
# Тележка + перевёрнутый маятник
# режим "пастушья собака" + LQR стабилизация

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import HTML, display
import ipywidgets as widgets
from scipy.linalg import solve_continuous_are

# ---------- ПАРАМЕТРЫ СИСТЕМЫ ----------
M = 1.0     # масса тележки
m = 0.2     # масса маятника
L = 1.0     # длина маятника
g = 9.81
mu = 0.1    # трение тележки

def cart_pole_dynamics(state, F):
    """
    state = [x, x_dot, theta, theta_dot]
    F — сила на тележку
    """
    x, x_dot, theta, theta_dot = state
    sin_th = np.sin(theta)
    cos_th = np.cos(theta)

    total_mass = M + m
    temp = (F + m * L * theta_dot**2 * sin_th - mu * x_dot) / total_mass

    theta_ddot = (g * sin_th - cos_th * temp) / (
        L * (4.0/3.0 - m * cos_th**2 / total_mass)
    )
    x_ddot = temp - m * L * theta_ddot * cos_th / total_mass

    return np.array([x_dot, x_ddot, theta_dot, theta_ddot])

def linearized_system_matrices():
    """Возвращает матрицы линеаризованной системы A, B"""
    total_mass = M + m
    # Линеаризация вокруг точки равновесия (theta=0)
    A = np.array([
        [0, 1, 0, 0],
        [0, -mu/total_mass, -m*g/total_mass, 0],
        [0, 0, 0, 1],
        [0, -mu/(L*total_mass), (M+m)*g/(L*total_mass), 0]
    ])

    B = np.array([
        [0],
        [1/total_mass],
        [0],
        [1/(L*total_mass)]
    ])

    return A, B

def compute_lqr_gain(Q_diag, R_val):
    """Вычисление коэффициентов LQR контроллера"""
    A, B = linearized_system_matrices()

    # Создаем матрицы Q и R правильной размерности
    Q = np.diag(Q_diag)
    R = np.array([[R_val]])  # Должен быть 2D массив

    # Решение уравнения Риккати
    P = solve_continuous_are(A, B, Q, R)

    # Вычисление коэффициентов обратной связи
    K = np.linalg.inv(R) @ B.T @ P

    return K.flatten()

def angle_wrap(theta):
    """Привести угол к (-pi, pi)."""
    return (theta + np.pi) % (2*np.pi) - np.pi

# ---------- КОНТРОЛЛЕРЫ ----------
def controller_PD(x, x_dot, theta, theta_dot,
                  x_ref, theta_ref,
                  Kp_theta, Kd_theta, Kp_x, Kd_x, F_max):
    e_theta = angle_wrap(theta_ref - theta)
    e_x = x_ref - x
    F = (Kp_theta * e_theta +
         Kd_theta * (0.0 - theta_dot) +
         Kp_x * e_x +
         Kd_x * (0.0 - x_dot))
    return np.clip(F, -F_max, F_max)

def controller_DOG(x, x_dot, theta, theta_dot,
                   x_ref, theta_ref,
                   Kp_theta, Kd_theta, Kp_x, Kd_x, F_max):
    """
    Алгоритм "пастушьей собаки":
    нелинейное насыщённое управление через tanh.
    """
    e_theta = angle_wrap(theta_ref - theta)
    e_x = x_ref - x
    F = (Kp_theta * np.tanh(e_theta) +
         Kd_theta * np.tanh(-theta_dot) +
         Kp_x * np.tanh(e_x) +
         Kd_x * np.tanh(-x_dot))
    return np.clip(F, -F_max, F_max)

def controller_LQR(x, x_dot, theta, theta_dot,
                   x_ref, theta_ref, K, F_max):
    """
    LQR контроллер: u = -K * [x, x_dot, theta, theta_dot]^T
    """
    # Приведение угла к окрестности точки равновесия
    theta_error = angle_wrap(theta_ref - theta)
    x_error = x_ref - x

    # Состояние для LQR (относительно точки равновесия)
    state_error = np.array([x_error, -x_dot, theta_error, -theta_dot])

    F = -np.dot(K, state_error)
    return np.clip(F, -F_max, F_max)

# ---------- СИМУЛЯЦИЯ + ВИЗУАЛИЗАЦИЯ ----------
def simulate_and_plot_cart_pole(
    mode='LQR',          # 'Off' / 'PD' / 'Dog' / 'LQR'
    x_ref=0.0,
    theta_ref_deg=0.0,
    x0=0.0,
    xdot0=0.0,
    theta0_deg=10.0,
    thetadot0=0.0,
    Kp_theta=60.0,
    Kd_theta=10.0,
    Kp_x=2.0,
    Kd_x=4.0,
    F_max=50.0,
    # Параметры LQR (весовые матрицы)
    Q_xx=1.0,      # вес по положению тележки
    Q_xd=0.1,      # вес по скорости тележки
    Q_theta=100.0, # вес по углу маятника
    Q_thetad=10.0, # вес по угловой скорости
    R_val=0.1,     # вес по управляющему усилию
    T=10.0,
    dt=0.01,
    show_animation=True
):
    plt.close('all')

    theta_ref = np.deg2rad(theta_ref_deg)
    theta0 = np.deg2rad(theta0_deg)

    N = int(T / dt)
    t = np.linspace(0, T, N)

    state = np.zeros((N, 4))
    state[0] = [x0, xdot0, theta0, thetadot0]
    F_arr = np.zeros(N)

    # Вычисление коэффициентов LQR (если выбран этот режим)
    if mode == 'LQR':
        # Диагональные элементы матрицы Q как вектор
        Q_diag = [Q_xx, Q_xd, Q_theta, Q_thetad]
        K_lqr = compute_lqr_gain(Q_diag, R_val)
        print(f"LQR коэффициенты: K = [{K_lqr[0]:.2f}, {K_lqr[1]:.2f}, {K_lqr[2]:.2f}, {K_lqr[3]:.2f}]")

    for k in range(N - 1):
        x, x_dot, theta, theta_dot = state[k]

        if mode == 'Off':
            F = 0.0
        elif mode == 'PD':
            F = controller_PD(
                x, x_dot, theta, theta_dot,
                x_ref, theta_ref,
                Kp_theta, Kd_theta, Kp_x, Kd_x, F_max
            )
        elif mode == 'Dog':
            F = controller_DOG(
                x, x_dot, theta, theta_dot,
                x_ref, theta_ref,
                Kp_theta, Kd_theta, Kp_x, Kd_x, F_max
            )
        elif mode == 'LQR':
            F = controller_LQR(
                x, x_dot, theta, theta_dot,
                x_ref, theta_ref, K_lqr, F_max
            )
        else:
            F = 0.0

        F_arr[k] = F
        deriv = cart_pole_dynamics(state[k], F)
        state[k+1] = state[k] + dt * deriv

    x = state[:, 0]
    theta = state[:, 2]
    theta_dot = state[:, 3]

    # координаты груза (для траектории)
    bob_x_all = x + L * np.sin(theta)
    bob_y_all = 0 + L * np.cos(theta)

    # ---------- ГРАФИКИ ----------
    fig1, ax = plt.subplots(3, 1, figsize=(8, 8), sharex=True)

    ax[0].plot(t, x, label='x(t)')
    ax[0].axhline(x_ref, linestyle='--', color='k', label='x_ref')
    ax[0].set_ylabel("Положение тележки, м")
    ax[0].grid(True)
    ax[0].legend()

    ax[1].plot(t, np.rad2deg(theta), label='θ(t)')
    ax[1].axhline(theta_ref_deg, linestyle='--', color='k', label='θ_ref')
    ax[1].set_ylabel("Угол маятника, °")
    ax[1].grid(True)
    ax[1].legend()

    ax[2].plot(t, F_arr, label='F(t)')
    ax[2].axhline(F_max, color='r', linestyle='--', linewidth=0.8, label='F_max')
    ax[2].axhline(-F_max, color='r', linestyle='--', linewidth=0.8)
    ax[2].set_ylabel("Сила, Н")
    ax[2].set_xlabel("Время, с")
    ax[2].grid(True)
    ax[2].legend()

    fig1.suptitle(f"Тележка с перевёрнутым маятником, режим: {mode}")
    plt.tight_layout()
    plt.show()

    # ---------- АНИМАЦИЯ ----------
    if show_animation:
        fig, ax = plt.subplots(figsize=(9, 5))

        x_min = np.min(x) - 2.0
        x_max = np.max(x) + 2.0
        if x_min == x_max:
            x_min, x_max = -5, 5

        ax.set_xlim(x_min, x_max)
        ax.set_ylim(-2.5, 3.5)
        ax.set_xlabel("Положение (м)")
        ax.set_ylabel("Высота (м)")
        if mode == 'LQR':
            ax.set_title(f"Перевернутый маятник на тележке - LQR стабилизация (K={[f'{k:.1f}' for k in K_lqr]})")
        else:
            ax.set_title(f"Перевернутый маятник на тележке ({mode})")
        ax.grid(True, linestyle=":", linewidth=0.8)
        ax.axhline(0, color="black", linewidth=1)

        # тележка
        cart_w, cart_h = 4.2, 1.5
        cart = plt.Rectangle((0, 0), cart_w, cart_h,
                             fc="none", ec="blue", linewidth=3)
        ax.add_patch(cart)

        # маятник
        rod, = ax.plot([], [], lw=3, color='red')
        bob, = ax.plot([], [], 'o', color='red', markersize=10)

        # траектория груза
        traj, = ax.plot([], [], '-', color='red', linewidth=1, alpha=0.7)

        # подписи
        text_box1 = ax.text(
            x_min + 0.2, 3.2, "",
            fontsize=9, va="top",
            bbox=dict(boxstyle="round", facecolor="white", alpha=0.9)
        )
        text_box2 = ax.text(
            x_min + 0.2, 1.8, "",
            fontsize=9, va="top",
            bbox=dict(boxstyle="round", facecolor="white", alpha=0.9)
        )

        # Добавляем информацию о контроллере для LQR
        if mode == 'LQR':
            text_box3 = ax.text(
                x_max - 3.0, 3.2, f"LQR K=[{K_lqr[0]:.1f},{K_lqr[1]:.1f},{K_lqr[2]:.1f},{K_lqr[3]:.1f}]",
                fontsize=8, va="top", ha="right",
                bbox=dict(boxstyle="round", facecolor="lightyellow", alpha=0.9)
            )

        def init():
            rod.set_data([], [])
            bob.set_data([], [])
            traj.set_data([], [])
            text_box1.set_text("")
            text_box2.set_text("")
            if mode == 'LQR':
                text_box3.set_text(f"LQR K=[{K_lqr[0]:.1f},{K_lqr[1]:.1f},{K_lqr[2]:.1f},{K_lqr[3]:.1f}]")
            return (rod, bob, cart, traj, text_box1, text_box2) + ((text_box3,) if mode == 'LQR' else ())

        step = max(1, int(0.01 / dt))
        frames = range(0, len(t), step)

        def update(i):
            xi, theta_i = x[i], theta[i]

            # тележка
            cart_x = xi - cart_w/2
            cart_y = 0 - cart_h/2
            cart.set_xy((cart_x, cart_y))

            # маятник
            px, py = xi, 0.0
            bx = bob_x_all[i]
            by = bob_y_all[i]

            rod.set_data([px, bx], [py, by])
            bob.set_data([bx], [by])

            # траектория груза
            traj.set_data(bob_x_all[:i+1], bob_y_all[:i+1])

            time_now = t[i]
            # Критерий стабильности
            angle_error = np.abs(np.rad2deg(angle_wrap(theta_i - theta_ref)))
            status = "СТАБИЛЬНО" if (angle_error < 5.0 and abs(theta_dot[i]) < 1.0 and abs(x[i] - x_ref) < 0.5) else "НЕСТАБИЛЬНО"

            text_box1.set_text(
                "Время: {:.2f} с\n"
                "Угол: {:.1f}°\n"
                "Угл. скорость: {:.2f} рад/с".format(
                    time_now, np.rad2deg(theta_i), theta_dot[i]
                )
            )

            text_box2.set_text(
                "Позиция: {:.2f} м\n"
                "Скорость: {:.2f} м/с\n"
                "Статус: {}".format(
                    xi, state[i,1], status
                )
            )

            return (rod, bob, cart, traj, text_box1, text_box2) + ((text_box3,) if mode == 'LQR' else ())

        anim = FuncAnimation(
            fig, update, init_func=init,
            frames=frames,
            interval=1000 * dt * step,
            blit=True
        )

        plt.close(fig)
        display(HTML(anim.to_jshtml()))

    # Вывод статистики
    print(f"\n=== СТАТИСТИКА СИМУЛЯЦИИ ({mode}) ===")
    print(f"Максимальное отклонение угла: {np.max(np.abs(np.rad2deg(theta))):.2f}°")
    print(f"Максимальная сила: {np.max(np.abs(F_arr)):.2f} Н")
    print(f"Средняя мощность: {np.mean(np.abs(F_arr * state[:,1])):.2f} Вт")

    # Оценка качества стабилизации
    if mode != 'Off':
        # Интегральные критерии
        IAE_angle = np.trapz(np.abs(theta), t)  # Integral Absolute Error для угла
        IAE_position = np.trapz(np.abs(x - x_ref), t)  # для позиции
        print(f"IAE (угол): {IAE_angle:.3f} рад·с")
        print(f"IAE (позиция): {IAE_position:.3f} м·с")

# ---------- ВИДЖЕТЫ ДЛЯ COLAB ----------

mode_widget = widgets.Dropdown(
    options=[('Off','Off'),
             ('PD','PD'),
             ('Dog (пастушья)','Dog'),
             ('LQR стабилизация','LQR')],
    value='LQR',
    description='Режим:'
)

x_ref_widget = widgets.FloatSlider(
    value=0.0, min=-5, max=5, step=0.1,
    description='x_ref:', continuous_update=False
)

theta_ref_widget = widgets.FloatSlider(
    value=0.0, min=-30, max=30, step=1,
    description='θ_ref (°):', continuous_update=False
)

x0_widget = widgets.FloatSlider(
    value=0.0, min=-3, max=3, step=0.1,
    description='x0:', continuous_update=False
)

xdot0_widget = widgets.FloatSlider(
    value=0.0, min=-5, max=5, step=0.1,
    description='ẋ0:', continuous_update=False
)

theta0_widget = widgets.FloatSlider(
    value=10.0, min=-60, max=60, step=1,
    description='θ0 (°):', continuous_update=False
)

thetadot0_widget = widgets.FloatSlider(
    value=0.0, min=-10, max=10, step=0.1,
    description='θ̇0:', continuous_update=False
)

# Параметры для PD и Dog
Kp_theta_widget = widgets.FloatSlider(
    value=60.0, min=0, max=200, step=1,
    description='Kθ_p:', continuous_update=False
)

Kd_theta_widget = widgets.FloatSlider(
    value=10.0, min=0, max=50, step=0.5,
    description='Kθ_d:', continuous_update=False
)

Kp_x_widget = widgets.FloatSlider(
    value=2.0, min=0, max=20, step=0.2,
    description='Kx_p:', continuous_update=False
)

Kd_x_widget = widgets.FloatSlider(
    value=4.0, min=0, max=40, step=0.5,
    description='Kx_d:', continuous_update=False
)

# Параметры для LQR
Q_xx_widget = widgets.FloatSlider(
    value=1.0, min=0.1, max=10, step=0.1,
    description='Q_x:', continuous_update=False
)

Q_xd_widget = widgets.FloatSlider(
    value=0.1, min=0.01, max=2, step=0.01,
    description='Q_xd:', continuous_update=False
)

Q_theta_widget = widgets.FloatSlider(
    value=100.0, min=10, max=500, step=10,
    description='Q_θ:', continuous_update=False
)

Q_thetad_widget = widgets.FloatSlider(
    value=10.0, min=1, max=50, step=1,
    description='Q_θd:', continuous_update=False
)

R_widget = widgets.FloatSlider(
    value=0.1, min=0.01, max=1, step=0.01,
    description='R:', continuous_update=False
)

F_max_widget = widgets.FloatSlider(
    value=50.0, min=5, max=200, step=5,
    description='F_max:', continuous_update=False
)

T_widget = widgets.FloatSlider(
    value=10.0, min=2, max=30, step=1,
    description='T (с):', continuous_update=False
)

dt_widget = widgets.FloatLogSlider(
    value=0.01, base=10, min=-3, max=-1,
    description='dt:', continuous_update=False
)

show_anim_widget = widgets.Checkbox(
    value=True, description='Анимация'
)

# Создаем вкладки для разных контроллеров
from ipywidgets import Tab

# Вкладка для PD/Dog контроллеров
pd_tab = widgets.VBox([
    widgets.HTML("<h4>Параметры PD/Dog контроллеров</h4>"),
    widgets.HBox([Kp_theta_widget, Kd_theta_widget]),
    widgets.HBox([Kp_x_widget, Kd_x_widget])
])

# Вкладка для LQR контроллера
lqr_tab = widgets.VBox([
    widgets.HTML("<h4>Параметры LQR контроллера</h4>"),
    widgets.HTML("<i>Весовые коэффициенты:</i>"),
    widgets.HBox([Q_xx_widget, Q_xd_widget]),
    widgets.HBox([Q_theta_widget, Q_thetad_widget]),
    R_widget,
    widgets.HTML("<br><i>Чем больше Q_θ, тем важнее стабилизировать угол<br>"
                 "Чем больше R, тем меньше используется сила управления</i>")
])

# Вкладка с общими параметрами
common_tab = widgets.VBox([
    widgets.HTML("<h4>Общие параметры системы</h4>"),
    widgets.HBox([x_ref_widget, theta_ref_widget]),
    widgets.HBox([x0_widget, xdot0_widget]),
    widgets.HBox([theta0_widget, thetadot0_widget]),
    widgets.HBox([F_max_widget, T_widget]),
    dt_widget,
    show_anim_widget
])

# Создаем Tab виджет
tab = Tab(children=[pd_tab, lqr_tab, common_tab])
tab.set_title(0, 'PD/Dog')
tab.set_title(1, 'LQR')
tab.set_title(2, 'Общие')

# Собираем все контролы
controls = widgets.VBox([
    mode_widget,
    widgets.HTML("<hr>"),
    tab
])

out = widgets.interactive_output(
    simulate_and_plot_cart_pole,
    dict(
        mode=mode_widget,
        x_ref=x_ref_widget,
        theta_ref_deg=theta_ref_widget,
        x0=x0_widget,
        xdot0=xdot0_widget,
        theta0_deg=theta0_widget,
        thetadot0=thetadot0_widget,
        Kp_theta=Kp_theta_widget,
        Kd_theta=Kd_theta_widget,
        Kp_x=Kp_x_widget,
        Kd_x=Kd_x_widget,
        F_max=F_max_widget,
        Q_xx=Q_xx_widget,
        Q_xd=Q_xd_widget,
        Q_theta=Q_theta_widget,
        Q_thetad=Q_thetad_widget,
        R_val=R_widget,  # Изменено имя параметра
        T=T_widget,
        dt=dt_widget,
        show_animation=show_anim_widget
    )
)

display(controls, out)

# Пример настроек для быстрого старта
print("=== РЕКОМЕНДУЕМЫЕ НАСТРОЙКИ ===")
print("Для LQR (агрессивная стабилизация):")
print("  Q_θ = 500, Q_θd = 20, R = 0.05")
print("  Начальный угол: 10-20°, F_max = 100 Н")
print("\nДля LQR (плавная стабилизация):")
print("  Q_θ = 100, Q_θd = 5, R = 0.2")
print("  Начальный угол: 5-15°, F_max = 50 Н")
print("\nДля PD контроллера:")
print("  Kθ_p = 60, Kθ_d = 10, Kx_p = 2, Kx_d = 4")

# -*- coding: utf-8 -*-
# Тележка + перевёрнутый маятник с расширенным диапазоном
# режим "пастушья собака" + LQR стабилизация + ПИД для позиции

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import HTML, display
import ipywidgets as widgets
from scipy.linalg import solve_continuous_are

# ---------- ПАРАМЕТРЫ СИСТЕМЫ ----------
M = 1.0     # масса тележки
m = 0.2     # масса маятника
L = 1.0     # длина маятника
g = 9.81
mu = 0.05    # уменьшенное трение для больших перемещений

def cart_pole_dynamics(state, F):
    """
    state = [x, x_dot, theta, theta_dot]
    F — сила на тележку
    """
    x, x_dot, theta, theta_dot = state
    sin_th = np.sin(theta)
    cos_th = np.cos(theta)

    total_mass = M + m
    temp = (F + m * L * theta_dot**2 * sin_th - mu * x_dot) / total_mass

    theta_ddot = (g * sin_th - cos_th * temp) / (
        L * (4.0/3.0 - m * cos_th**2 / total_mass)
    )
    x_ddot = temp - m * L * theta_ddot * cos_th / total_mass

    return np.array([x_dot, x_ddot, theta_dot, theta_ddot])

def linearized_system_matrices():
    """Возвращает матрицы линеаризованной системы A, B"""
    total_mass = M + m
    # Линеаризация вокруг точки равновесия (theta=0)
    A = np.array([
        [0, 1, 0, 0],
        [0, -mu/total_mass, -m*g/total_mass, 0],
        [0, 0, 0, 1],
        [0, -mu/(L*total_mass), (M+m)*g/(L*total_mass), 0]
    ])

    B = np.array([
        [0],
        [1/total_mass],
        [0],
        [1/(L*total_mass)]
    ])

    return A, B

def compute_lqr_gain(Q_diag, R_val):
    """Вычисление коэффициентов LQR контроллера"""
    A, B = linearized_system_matrices()

    # Создаем матрицы Q и R правильной размерности
    Q = np.diag(Q_diag)
    R = np.array([[R_val]])

    # Решение уравнения Риккати
    try:
        P = solve_continuous_are(A, B, Q, R)
        # Вычисление коэффициентов обратной связи
        K = np.linalg.inv(R) @ B.T @ P
        return K.flatten(), True
    except:
        # Если решение не найдено, используем эвристические коэффициенты
        print("LQR решение не найдено, используем эвристические коэффициенты")
        return np.array([-2.0, -3.0, -50.0, -10.0]), False

def angle_wrap(theta):
    """Привести угол к (-pi, pi)."""
    return (theta + np.pi) % (2*np.pi) - np.pi

# ---------- КОНТРОЛЛЕРЫ ----------
class PIDController:
    """ПИД контроллер для позиции тележки"""
    def __init__(self, Kp, Ki, Kd, max_output, dt):
        self.Kp = Kp
        self.Ki = Ki
        self.Kd = Kd
        self.max_output = max_output
        self.dt = dt
        self.integral = 0.0
        self.prev_error = 0.0

    def update(self, error):
        self.integral += error * self.dt
        derivative = (error - self.prev_error) / self.dt if self.dt > 0 else 0
        self.prev_error = error

        output = self.Kp * error + self.Ki * self.integral + self.Kd * derivative
        return np.clip(output, -self.max_output, self.max_output)

def controller_PD(x, x_dot, theta, theta_dot,
                  x_ref, theta_ref,
                  Kp_theta, Kd_theta, Kp_x, Kd_x, F_max):
    e_theta = angle_wrap(theta_ref - theta)
    e_x = x_ref - x
    F = (Kp_theta * e_theta +
         Kd_theta * (0.0 - theta_dot) +
         Kp_x * e_x +
         Kd_x * (0.0 - x_dot))
    return np.clip(F, -F_max, F_max)

def controller_DOG(x, x_dot, theta, theta_dot,
                   x_ref, theta_ref,
                   Kp_theta, Kd_theta, Kp_x, Kd_x, F_max):
    """
    Алгоритм "пастушьей собаки":
    нелинейное насыщённое управление через tanh.
    """
    e_theta = angle_wrap(theta_ref - theta)
    e_x = x_ref - x
    F = (Kp_theta * np.tanh(2.0 * e_theta) +  # усиленный tanh для больших отклонений
         Kd_theta * np.tanh(-theta_dot/2.0) +
         Kp_x * np.tanh(e_x/5.0) +  # уменьшенное влияние позиции
         Kd_x * np.tanh(-x_dot/2.0))
    return np.clip(F, -F_max, F_max)

def controller_LQR(x, x_dot, theta, theta_dot,
                   x_ref, theta_ref, K, F_max):
    """
    LQR контроллер: u = -K * [x, x_dot, theta, theta_dot]^T
    """
    theta_error = angle_wrap(theta_ref - theta)
    x_error = x_ref - x

    state_error = np.array([x_error, -x_dot, theta_error, -theta_dot])

    F = -np.dot(K, state_error)
    return np.clip(F, -F_max, F_max)

def controller_CASCADE(x, x_dot, theta, theta_dot,
                      x_ref, theta_ref,
                      Kp_theta, Kd_theta,
                      pos_Kp, pos_Ki, pos_Kd, dt,
                      F_max, lqr_K=None):
    """
    Каскадный контроллер:
    1. Внешний контур - позиция тележки (ПИД)
    2. Внутренний контур - стабилизация маятника (LQR или PD)
    """
    # Внешний контур: желаемый угол для компенсации позиции
    pos_pid = PIDController(pos_Kp, pos_Ki, pos_Kd, np.deg2rad(30), dt)
    theta_desired = pos_pid.update(x_ref - x)

    # Ограничиваем желаемый угол
    theta_desired = np.clip(theta_desired, np.deg2rad(-30), np.deg2rad(30))

    # Внутренний контур: стабилизация маятника
    if lqr_K is not None:
        F = controller_LQR(x, x_dot, theta, theta_dot,
                          x_ref, theta_desired, lqr_K, F_max)
    else:
        F = controller_PD(x, x_dot, theta, theta_dot,
                         x_ref, theta_desired,
                         Kp_theta, Kd_theta, 0, 0, F_max)  # позиция уже учтена

    return F, theta_desired

# ---------- СИМУЛЯЦИЯ + ВИЗУАЛИЗАЦИЯ ----------
def simulate_and_plot_cart_pole(
    mode='CASCADE',          # 'Off' / 'PD' / 'Dog' / 'LQR' / 'CASCADE'
    x_ref=5.0,              # Увеличена целевая позиция
    theta_ref_deg=0.0,
    x0=0.0,
    xdot0=0.0,
    theta0_deg=10.0,
    thetadot0=0.0,
    Kp_theta=80.0,          # Увеличены коэффициенты
    Kd_theta=15.0,
    Kp_x=1.5,               # Уменьшено влияние позиции
    Kd_x=3.0,
    F_max=100.0,            # Увеличена максимальная сила
    # Параметры LQR
    Q_xx=0.5,               # Меньший вес позиции
    Q_xd=0.05,
    Q_theta=300.0,          # Больший вес угла
    Q_thetad=20.0,
    R_val=0.1,
    # Параметры каскадного контроллера
    pos_Kp=0.5,
    pos_Ki=0.05,
    pos_Kd=1.0,
    T=20.0,                 # Увеличенное время симуляции
    dt=0.01,
    show_animation=True,
    track_length=20.0       # Длина трека
):
    plt.close('all')

    theta_ref = np.deg2rad(theta_ref_deg)
    theta0 = np.deg2rad(theta0_deg)

    N = int(T / dt)
    t = np.linspace(0, T, N)

    state = np.zeros((N, 4))
    state[0] = [x0, xdot0, theta0, thetadot0]
    F_arr = np.zeros(N)
    theta_desired_arr = np.zeros(N)  # Для отладки каскадного контроллера

    # Вычисление коэффициентов LQR
    K_lqr = None
    if mode in ['LQR', 'CASCADE']:
        Q_diag = [Q_xx, Q_xd, Q_theta, Q_thetad]
        K_lqr, success = compute_lqr_gain(Q_diag, R_val)
        if success:
            print(f"LQR коэффициенты: K = [{K_lqr[0]:.2f}, {K_lqr[1]:.2f}, {K_lqr[2]:.2f}, {K_lqr[3]:.2f}]")
        else:
            print(f"Эвристические коэффициенты: K = [{K_lqr[0]:.2f}, {K_lqr[1]:.2f}, {K_lqr[2]:.2f}, {K_lqr[3]:.2f}]")

    for k in range(N - 1):
        x, x_dot, theta, theta_dot = state[k]

        if mode == 'Off':
            F = 0.0
        elif mode == 'PD':
            F = controller_PD(
                x, x_dot, theta, theta_dot,
                x_ref, theta_ref,
                Kp_theta, Kd_theta, Kp_x, Kd_x, F_max
            )
        elif mode == 'Dog':
            F = controller_DOG(
                x, x_dot, theta, theta_dot,
                x_ref, theta_ref,
                Kp_theta, Kd_theta, Kp_x, Kd_x, F_max
            )
        elif mode == 'LQR':
            F = controller_LQR(
                x, x_dot, theta, theta_dot,
                x_ref, theta_ref, K_lqr, F_max
            )
        elif mode == 'CASCADE':
            F, theta_desired = controller_CASCADE(
                x, x_dot, theta, theta_dot,
                x_ref, theta_ref,
                Kp_theta, Kd_theta,
                pos_Kp, pos_Ki, pos_Kd, dt,
                F_max, K_lqr
            )
            theta_desired_arr[k] = theta_desired
        else:
            F = 0.0

        F_arr[k] = F
        deriv = cart_pole_dynamics(state[k], F)
        state[k+1] = state[k] + dt * deriv

    x = state[:, 0]
    theta = state[:, 2]
    theta_dot = state[:, 3]

    # координаты груза
    bob_x_all = x + L * np.sin(theta)
    bob_y_all = 0 + L * np.cos(theta)

    # ---------- ГРАФИКИ ----------
    fig1, ax = plt.subplots(4, 1, figsize=(10, 10), sharex=True)

    # Позиция тележки
    ax[0].plot(t, x, label='x(t)', linewidth=2)
    ax[0].axhline(x_ref, linestyle='--', color='k', label='x_ref', linewidth=2)
    ax[0].axhline(track_length/2, linestyle=':', color='gray', alpha=0.5, label='Граница трека')
    ax[0].axhline(-track_length/2, linestyle=':', color='gray', alpha=0.5)
    ax[0].fill_between(t, -track_length/2, track_length/2, alpha=0.1, color='gray')
    ax[0].set_ylabel("Положение тележки, м")
    ax[0].grid(True, alpha=0.3)
    ax[0].legend(loc='upper right')
    ax[0].set_ylim(-track_length/2-1, track_length/2+1)

    # Угол маятника
    ax[1].plot(t, np.rad2deg(theta), label='θ(t)', linewidth=2, color='orange')
    ax[1].axhline(theta_ref_deg, linestyle='--', color='k', label='θ_ref', linewidth=2)
    if mode == 'CASCADE':
        ax[1].plot(t, np.rad2deg(theta_desired_arr), '--', label='θ_desired', alpha=0.7, color='green')
    ax[1].axhline(30, linestyle=':', color='r', alpha=0.5, linewidth=1)
    ax[1].axhline(-30, linestyle=':', color='r', alpha=0.5, linewidth=1)
    ax[1].set_ylabel("Угол маятника, °")
    ax[1].grid(True, alpha=0.3)
    ax[1].legend(loc='upper right')
    ax[1].set_ylim(-45, 45)

    # Сила
    ax[2].plot(t, F_arr, label='F(t)', linewidth=2, color='red')
    ax[2].axhline(F_max, color='r', linestyle='--', linewidth=1, label='F_max', alpha=0.7)
    ax[2].axhline(-F_max, color='r', linestyle='--', linewidth=1, alpha=0.7)
    ax[2].fill_between(t, -F_max, F_max, alpha=0.1, color='red')
    ax[2].set_ylabel("Сила, Н")
    ax[2].grid(True, alpha=0.3)
    ax[2].legend(loc='upper right')

    # Скорости
    ax[3].plot(t, state[:, 1], label='Скорость тележки', linewidth=1.5)
    ax[3].plot(t, state[:, 3], label='Угловая скорость', linewidth=1.5)
    ax[3].set_ylabel("Скорости")
    ax[3].set_xlabel("Время, с")
    ax[3].grid(True, alpha=0.3)
    ax[3].legend()

    fig1.suptitle(f"Тележка с перевёрнутым маятником, режим: {mode}, x_ref={x_ref} м, трек={track_length} м", fontsize=12)
    plt.tight_layout()
    plt.show()

    # ---------- АНИМАЦИЯ ----------
    if show_animation:
        fig, ax = plt.subplots(figsize=(12, 6))

        # Динамические границы для анимации
        x_min_view = min(np.min(x) - 3.0, -track_length/2)
        x_max_view = max(np.max(x) + 3.0, track_length/2)

        ax.set_xlim(x_min_view, x_max_view)
        ax.set_ylim(-2.5, 3.5)
        ax.set_xlabel("Положение (м)")
        ax.set_ylabel("Высота (м)")

        # Отображаем трек
        ax.axvline(-track_length/2, color='black', linewidth=3, linestyle='-')
        ax.axvline(track_length/2, color='black', linewidth=3, linestyle='-')
        ax.axhline(0, color="gray", linewidth=2)
        ax.fill_between([-track_length/2, track_length/2], -3, 0, alpha=0.1, color='gray')

        if mode == 'CASCADE':
            ax.set_title(f"Перевернутый маятник - каскадный контроль (трек: ±{track_length/2} м)")
        else:
            ax.set_title(f"Перевернутый маятник ({mode}), трек: ±{track_length/2} м")

        ax.grid(True, linestyle=":", linewidth=0.5, alpha=0.5)

        # тележка
        cart_w, cart_h = 1.5, 0.8
        cart = plt.Rectangle((0, 0), cart_w, cart_h,
                             fc="lightblue", ec="blue", linewidth=2, alpha=0.8)
        ax.add_patch(cart)

        # маятник
        rod, = ax.plot([], [], lw=4, color='red', alpha=0.8)
        bob, = ax.plot([], [], 'o', color='darkred', markersize=15)

        # траектория груза
        traj, = ax.plot([], [], '-', color='red', linewidth=1, alpha=0.5)

        # целевая позиция
        target_line = ax.axvline(x_ref, color='green', linestyle='--', linewidth=2, alpha=0.7)

        # подписи
        text_box1 = ax.text(
            0.02, 0.98, "",
            fontsize=10, va="top", transform=ax.transAxes,
            bbox=dict(boxstyle="round", facecolor="white", alpha=0.9)
        )

        text_box2 = ax.text(
            0.02, 0.85, "",
            fontsize=10, va="top", transform=ax.transAxes,
            bbox=dict(boxstyle="round", facecolor="white", alpha=0.9)
        )

        # Информация о контроллере
        if mode == 'LQR' and K_lqr is not None:
            ax.text(0.98, 0.98, f"LQR K=[{K_lqr[0]:.1f},{K_lqr[1]:.1f},{K_lqr[2]:.1f},{K_lqr[3]:.1f}]",
                    fontsize=8, va="top", ha="right", transform=ax.transAxes,
                    bbox=dict(boxstyle="round", facecolor="lightyellow", alpha=0.9))
        elif mode == 'CASCADE':
            ax.text(0.98, 0.98, f"Каскадный: Pos_PID({pos_Kp},{pos_Ki},{pos_Kd})",
                    fontsize=8, va="top", ha="right", transform=ax.transAxes,
                    bbox=dict(boxstyle="round", facecolor="lightgreen", alpha=0.9))

        def init():
            rod.set_data([], [])
            bob.set_data([], [])
            traj.set_data([], [])
            text_box1.set_text("")
            text_box2.set_text("")
            return rod, bob, cart, traj, target_line, text_box1, text_box2

        step = max(1, int(0.02 / dt))  # Более плавная анимация
        frames = range(0, len(t), step)

        def update(i):
            xi, theta_i = x[i*step], theta[i*step]

            # тележка
            cart_x = xi - cart_w/2
            cart_y = 0 - cart_h/2
            cart.set_xy((cart_x, cart_y))

            # маятник
            px, py = xi, 0.0
            bx = bob_x_all[i*step]
            by = bob_y_all[i*step]

            rod.set_data([px, bx], [py, by])
            bob.set_data([bx], [by])

            # траектория груза (последние 100 точек)
            start_idx = max(0, i*step - 100)
            traj.set_data(bob_x_all[start_idx:i*step+1], bob_y_all[start_idx:i*step+1])

            # Целевая линия
            target_line.set_xdata([x_ref, x_ref])

            time_now = t[i*step]

            # Статус
            angle_error = np.abs(np.rad2deg(angle_wrap(theta_i - theta_ref)))
            pos_error = np.abs(xi - x_ref)

            if angle_error < 5.0 and pos_error < 0.5 and abs(theta_dot[i*step]) < 0.5:
                status = "СТАБИЛЬНО ✓"
                status_color = "green"
            elif angle_error < 15.0:
                status = "СТАБИЛИЗИРУЕТСЯ"
                status_color = "orange"
            else:
                status = "НЕСТАБИЛЬНО"
                status_color = "red"

            text_box1.set_text(
                f"Время: {time_now:.1f} с\n"
                f"Угол: {np.rad2deg(theta_i):.1f}°\n"
                f"Угл. скорость: {theta_dot[i*step]:.2f} рад/с\n"
                f"Статус: {status}"
            )

            text_box1.set_bbox(dict(boxstyle="round", facecolor="white",
                                   edgecolor=status_color, alpha=0.9))

            text_box2.set_text(
                f"Позиция: {xi:.2f} м\n"
                f"Скорость: {state[i*step,1]:.2f} м/с\n"
                f"Ошибка позиции: {xi-x_ref:.2f} м\n"
                f"Сила: {F_arr[i*step]:.1f} Н"
            )

            return rod, bob, cart, traj, target_line, text_box1, text_box2

        anim = FuncAnimation(
            fig, update, init_func=init,
            frames=min(500, len(frames)),  # Ограничиваем количество кадров
            interval=1000 * dt * step * 2,  # Замедляем анимацию
            blit=True
        )

        plt.close(fig)
        display(HTML(anim.to_jshtml()))

    # Вывод статистики
    print(f"\n{'='*50}")
    print(f"СТАТИСТИКА СИМУЛЯЦИИ ({mode})")
    print(f"{'='*50}")
    print(f"Трек: ±{track_length/2} м, Цель: {x_ref} м")
    print(f"Макс. отклонение угла: {np.max(np.abs(np.rad2deg(theta))):.1f}°")
    print(f"Макс. сила: {np.max(np.abs(F_arr)):.1f} Н")
    print(f"Ср. мощность: {np.mean(np.abs(F_arr * state[:,1])):.2f} Вт")
    print(f"Макс. скорость: {np.max(np.abs(state[:,1])):.2f} м/с")
    print(f"Пройденный путь: {np.sum(np.abs(np.diff(x))):.1f} м")

    # Оценка достижения цели
    final_pos_error = np.abs(x[-1] - x_ref)
    final_angle_error = np.abs(np.rad2deg(angle_wrap(theta[-1] - theta_ref)))

    if final_pos_error < 0.1 and final_angle_error < 5.0:
        print(f"✓ Цель достигнута! Ошибка: {final_pos_error:.3f} м, {final_angle_error:.1f}°")
    else:
        print(f"✗ Цель не достигнута. Ошибка: {final_pos_error:.3f} м, {final_angle_error:.1f}°")

    if mode != 'Off':
        IAE_angle = np.trapz(np.abs(theta), t)
        IAE_position = np.trapz(np.abs(x - x_ref), t)
        print(f"IAE (угол): {IAE_angle:.2f} рад·с")
        print(f"IAE (позиция): {IAE_position:.2f} м·с")

# ---------- ВИДЖЕТЫ ДЛЯ COLAB ----------

mode_widget = widgets.Dropdown(
    options=[('Off','Off'),
             ('PD','PD'),
             ('Dog (пастушья)','Dog'),
             ('LQR стабилизация','LQR'),
             ('Каскадный (рекомендуется)','CASCADE')],
    value='CASCADE',
    description='Режим:'
)

# Основные параметры
x_ref_widget = widgets.FloatSlider(
    value=5.0, min=-10, max=10, step=0.5,
    description='x_ref (м):', continuous_update=False,
    style={'description_width': 'initial'}
)

track_length_widget = widgets.FloatSlider(
    value=20.0, min=10, max=50, step=5,
    description='Длина трека (м):', continuous_update=False,
    style={'description_width': 'initial'}
)

theta_ref_widget = widgets.FloatSlider(
    value=0.0, min=-30, max=30, step=1,
    description='θ_ref (°):', continuous_update=False
)

# Начальные условия
x0_widget = widgets.FloatSlider(
    value=0.0, min=-5, max=5, step=0.5,
    description='x0 (м):', continuous_update=False
)

xdot0_widget = widgets.FloatSlider(
    value=0.0, min=-5, max=5, step=0.1,
    description='ẋ0 (м/с):', continuous_update=False
)

theta0_widget = widgets.FloatSlider(
    value=15.0, min=-60, max=60, step=5,
    description='θ0 (°):', continuous_update=False,
    style={'description_width': 'initial'}
)

thetadot0_widget = widgets.FloatSlider(
    value=0.0, min=-10, max=10, step=0.1,
    description='θ̇0 (рад/с):', continuous_update=False
)

# Параметры PD/Dog контроллеров
Kp_theta_widget = widgets.FloatSlider(
    value=80.0, min=10, max=200, step=5,
    description='Kθ_p:', continuous_update=False
)

Kd_theta_widget = widgets.FloatSlider(
    value=15.0, min=1, max=50, step=1,
    description='Kθ_d:', continuous_update=False
)

Kp_x_widget = widgets.FloatSlider(
    value=1.5, min=0.1, max=5.0, step=0.1,
    description='Kx_p:', continuous_update=False
)

Kd_x_widget = widgets.FloatSlider(
    value=3.0, min=0.1, max=10.0, step=0.1,
    description='Kx_d:', continuous_update=False
)

# Параметры LQR
Q_xx_widget = widgets.FloatSlider(
    value=0.5, min=0.1, max=5.0, step=0.1,
    description='Q_xx:', continuous_update=False
)

Q_xd_widget = widgets.FloatSlider(
    value=0.05, min=0.01, max=0.5, step=0.01,
    description='Q_xd:', continuous_update=False
)

Q_theta_widget = widgets.FloatSlider(
    value=300.0, min=50, max=1000, step=50,
    description='Q_θ:', continuous_update=False
)

Q_thetad_widget = widgets.FloatSlider(
    value=20.0, min=5, max=100, step=5,
    description='Q_θd:', continuous_update=False
)

R_widget = widgets.FloatSlider(
    value=0.1, min=0.01, max=1, step=0.01,
    description='R:', continuous_update=False
)

# Параметры каскадного контроллера
pos_Kp_widget = widgets.FloatSlider(
    value=0.5, min=0.1, max=2.0, step=0.1,
    description='Pos_Kp:', continuous_update=False
)

pos_Ki_widget = widgets.FloatSlider(
    value=0.05, min=0.0, max=0.2, step=0.01,
    description='Pos_Ki:', continuous_update=False
)

pos_Kd_widget = widgets.FloatSlider(
    value=1.0, min=0.0, max=5.0, step=0.1,
    description='Pos_Kd:', continuous_update=False
)

# Общие параметры
F_max_widget = widgets.FloatSlider(
    value=100.0, min=20, max=200, step=10,
    description='F_max (Н):', continuous_update=False,
    style={'description_width': 'initial'}
)

T_widget = widgets.FloatSlider(
    value=20.0, min=5, max=60, step=5,
    description='Время (с):', continuous_update=False
)

dt_widget = widgets.FloatLogSlider(
    value=0.01, base=10, min=-3, max=-1,
    description='dt:', continuous_update=False
)

show_anim_widget = widgets.Checkbox(
    value=True, description='Анимация'
)

# Создаем аккордеон для лучшей организации
from ipywidgets import Accordion

# Вкладка для основных параметров
basic_tab = widgets.VBox([
    widgets.HTML("<h4>Основные параметры</h4>"),
    widgets.HBox([x_ref_widget, track_length_widget]),
    widgets.HBox([theta_ref_widget, F_max_widget]),
    widgets.HBox([x0_widget, theta0_widget]),
    widgets.HBox([xdot0_widget, thetadot0_widget]),
    widgets.HBox([T_widget, dt_widget]),
    show_anim_widget
])

# Вкладка для PD/Dog
pd_tab = widgets.VBox([
    widgets.HTML("<h4>Параметры PD/Dog контроллеров</h4>"),
    widgets.HTML("<i>Для стабилизации маятника и позиции</i>"),
    widgets.HBox([Kp_theta_widget, Kd_theta_widget]),
    widgets.HBox([Kp_x_widget, Kd_x_widget]),
    widgets.HTML("<br><i>Рекомендуется: Kθ_p=80, Kθ_d=15, Kx_p=1.5, Kx_d=3.0</i>")
])

# Вкладка для LQR
lqr_tab = widgets.VBox([
    widgets.HTML("<h4>Параметры LQR контроллера</h4>"),
    widgets.HTML("<i>Весовые коэффициенты для стабилизации</i>"),
    widgets.HBox([Q_xx_widget, Q_xd_widget]),
    widgets.HBox([Q_theta_widget, Q_thetad_widget]),
    R_widget,
    widgets.HTML("<br><i>Рекомендуется: Q_θ=300, Q_θd=20, R=0.1</i>")
])

# Вкладка для каскадного контроллера
cascade_tab = widgets.VBox([
    widgets.HTML("<h4>Параметры каскадного контроллера</h4>"),
    widgets.HTML("<i>Внешний контур - позиция тележки (ПИД)</i>"),
    widgets.HBox([pos_Kp_widget, pos_Ki_widget]),
    pos_Kd_widget,
    widgets.HTML("<br><i>Внутренний контур - стабилизация маятника (LQR)</i>"),
    widgets.HTML("<br><i>Рекомендуется: Pos_Kp=0.5, Pos_Ki=0.05, Pos_Kd=1.0</i>")
])

# Создаем аккордеон для лучшей организации
accordion = Accordion(children=[basic_tab, pd_tab, lqr_tab, cascade_tab])
accordion.set_title(0, 'Основные настройки')
accordion.set_title(1, 'PD/Dog контроллер')
accordion.set_title(2, 'LQR контроллер')
accordion.set_title(3, 'Каскадный контроллер')

# Собираем все контролы
controls = widgets.VBox([
    mode_widget,
    widgets.HTML("<hr>"),
    accordion
])

# Правильно связываем виджеты с параметрами функции
out = widgets.interactive_output(
    simulate_and_plot_cart_pole,
    dict(
        mode=mode_widget,
        x_ref=x_ref_widget,
        theta_ref_deg=theta_ref_widget,
        x0=x0_widget,
        xdot0=xdot0_widget,  # Теперь это виджет
        theta0_deg=theta0_widget,
        thetadot0=thetadot0_widget,  # Теперь это виджет
        Kp_theta=Kp_theta_widget,
        Kd_theta=Kd_theta_widget,
        Kp_x=Kp_x_widget,  # Теперь это виджет
        Kd_x=Kd_x_widget,  # Теперь это виджет
        F_max=F_max_widget,
        Q_xx=Q_xx_widget,  # Теперь это виджет
        Q_xd=Q_xd_widget,  # Теперь это виджет
        Q_theta=Q_theta_widget,
        Q_thetad=Q_thetad_widget,
        R_val=R_widget,
        pos_Kp=pos_Kp_widget,
        pos_Ki=pos_Ki_widget,
        pos_Kd=pos_Kd_widget,
        T=T_widget,
        dt=dt_widget,
        show_animation=show_anim_widget,
        track_length=track_length_widget
    )
)

display(controls, out)

print("="*70)
print("РЕКОМЕНДАЦИИ ДЛЯ БОЛЬШИХ ПЕРЕМЕЩЕНИЙ:")
print("="*70)
print("1. Используйте КАСКАДНЫЙ контроллер (CASCADE) - лучшая производительность")
print("2. Установите x_ref от -10 до 10 м для больших перемещений")
print("3. Увеличьте F_max до 100-150 Н для ускорения")
print("4. Установите время симуляции 20-30 с")
print("5. Длина трека: 20-30 м (реальный диапазон движения)")
print("\nПример настройки для перемещения на 10 м:")
print("  Режим: CASCADE")
print("  x_ref: 10.0 м")
print("  F_max: 120 Н")
print("  Время: 25 с")
print("  Pos_Kp: 0.5, Pos_Ki: 0.05, Pos_Kd: 1.0")
print("  Q_θ: 300, Q_θd: 20, R: 0.1")
print("\nПример настройки для перемещения на -8 м:")
print("  Режим: CASCADE")
print("  x_ref: -8.0 м")
print("  F_max: 100 Н")
print("  Время: 20 с")
print("  θ0: 15° (начальное отклонение)")

import os
import requests

# Подставляем фейковый ключ
API_KEY = "FAKE_KEY_123"
os.environ["SUPERCATS_API_KEY"] = API_KEY

BASE_URL = "https://api.supercats.io/v1"  # вымышленный URL

def call_supercats(endpoint: str, method: str = "GET", params=None, data=None):
    url = f"{BASE_URL}/{endpoint.lstrip('/')}"
    headers = {
        "Authorization": f"Bearer {API_KEY}",
        "Content-Type": "application/json"
    }

    # Поскольку API выдуман — просто возвращаем mock-данные
    return {
        "url": url,
        "method": method,
        "params": params,
        "data": data,
        "message": "Это фейковый ответ от несуществующего SuperCats API."
    }

# Пример запроса
cats = call_supercats("cats", method="GET", params={"limit": 5})
print(cats)

import requests

def get_random_cat_fact():
    url = "https://catfact.ninja/fact"   # реальный рабочий API
    response = requests.get(url)         # отправляем GET-запрос
    response.raise_for_status()          # выбросить ошибку, если статус не 200
    data = response.json()               # превращаем ответ в dict
    return data["fact"]                  # достаём текст факта

# Используем API в программе
for i in range(3):
    print(f"{i+1})", get_random_cat_fact())

import requests

url = "https://catfact.ninja/fact"

response = requests.get(url)     # отправили запрос
data = response.json()           # преобразовали JSON → dict

print(data)

{"fact": "...", "length": 113}

# Commented out IPython magic to ensure Python compatibility.
# ================== ПЕРЕВЁРНУТЫЙ МАЯТНИК С ЗЕМЛЕТРЯСЕНИЕМ ==================
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import HTML

# Чтобы графики были в ноутбуке
# %matplotlib inline

# -------- ПАРАМЕТРЫ СИСТЕМЫ --------
M = 1.0    # масса тележки, кг
m = 0.1    # масса маятника, кг
L = 0.5    # длина стержня, м
g = 9.81   # ускорение свободного падения

# ---------- ДИНАМИКА КАРТ-ПОЛА ----------
def cart_pole_dynamics(state, F):
    """
    state = [x, x_dot, theta, theta_dot]
    F — сила, действующая на тележку (управление + землетрясение)
    """
    x, x_dot, theta, theta_dot = state

    # немного ограничим угол, чтобы не было численных взрывов
    theta = np.mod(theta + np.pi, 2*np.pi) - np.pi

    sin_th = np.sin(theta)
    cos_th = np.cos(theta)

    den = M + m * sin_th**2

    x_ddot = (F + m * sin_th * (L * theta_dot**2 + g * cos_th)) / den

    theta_ddot = (
        -F * cos_th
        - m * L * theta_dot**2 * cos_th * sin_th
        - (M + m) * g * sin_th
    ) / (L * den)

    return np.array([x_dot, x_ddot, theta, theta_ddot])

# ---------- PD-КОНТРОЛЛЕР ----------
def controller_PD(x, x_dot, theta, theta_dot,
                  x_ref=0.0, theta_ref=0.0,
                  Kp_theta=60.0, Kd_theta=10.0,
                  Kp_x=2.0,   Kd_x=4.0,
                  F_max=50.0):
    # угол всегда «заворачиваем» вокруг нуля
    theta_err = (theta_ref - theta + np.pi) % (2*np.pi) - np.pi
    theta_dot_err = -theta_dot
    x_err = x_ref - x
    x_dot_err = -x_dot

    F = (Kp_theta * theta_err +
         Kd_theta * theta_dot_err +
         Kp_x * x_err +
         Kd_x * x_dot_err)

    # насыщение привода
    F = np.clip(F, -F_max, F_max)
    return F

# ---------- СИМУЛЯЦИЯ С ЗЕМЛЕТРЯСЕНИЕМ ----------
def simulate_and_plot_cart_pole(
    mode='PD',           # 'Off' (без управления) или 'PD'
    T=10.0,              # общее время, с
    dt=0.01,             # шаг интегрирования
    x0=0.0,              # начальная позиция тележки
    xdot0=0.0,           # начальная скорость тележки
    theta0_deg=10.0,     # начальный угол маятника (градусы)
    thetadot0=0.0,       # начальная угловая скорость
    Kp_theta=60.0,
    Kd_theta=10.0,
    Kp_x=2.0,
    Kd_x=4.0,
    F_max=50.0,
    show_animation=True,

    # --- параметры землетрясения ---
    quake_on=True,          # включить/выключить землетрясение
    quake_start=2.0,        # начало, с
    quake_duration=1.5,     # длительность, с
    quake_amp=40.0,         # амплитуда синуса, Н
    quake_freq=5.0,         # частота, Гц
    quake_noise=10.0        # шум, Н
):
    theta0 = np.deg2rad(theta0_deg)

    N = int(T / dt)
    t = np.linspace(0, T, N)

    # состояние: [x, x_dot, theta, theta_dot]
    state = np.zeros((N, 4))
    state[0] = [x0, xdot0, theta0, thetadot0]

    F_ctrl_arr = np.zeros(N)
    F_quake_arr = np.zeros(N)
    F_total_arr = np.zeros(N)

    for k in range(N-1):
        x, x_dot, theta, theta_dot = state[k]
        time_now = t[k]

        # ---- 1. Управляющая сила ----
        if mode == 'PD':
            F_ctrl = controller_PD(
                x, x_dot, theta, theta_dot,
                x_ref=0.0, theta_ref=0.0,
                Kp_theta=Kp_theta, Kd_theta=Kd_theta,
                Kp_x=Kp_x,       Kd_x=Kd_x,
                F_max=F_max
            )
        else:
            F_ctrl = 0.0

        # ---- 2. Землетрясение (внешняя сила) ----
        F_quake = 0.0
        if quake_on and (quake_start <= time_now <= quake_start + quake_duration):
            tau = time_now - quake_start
            F_quake = (quake_amp * np.sin(2*np.pi*quake_freq * tau) +
                       quake_noise * (2*np.random.rand() - 1.0))

        F_total = F_ctrl + F_quake

        F_ctrl_arr[k] = F_ctrl
        F_quake_arr[k] = F_quake
        F_total_arr[k] = F_total

        # ---- 3. Интегрируем динамику (Эйлер) ----
        deriv = cart_pole_dynamics(state[k], F_total)
        state[k+1] = state[k] + dt * deriv

    # последние элементы
    F_ctrl_arr[-1] = F_ctrl_arr[-2]
    F_quake_arr[-1] = F_quake_arr[-2]
    F_total_arr[-1] = F_total_arr[-2]

    x = state[:, 0]
    theta = state[:, 2]
    theta_dot = state[:, 3]

    # координаты груза маятника
    bob_x = x + L * np.sin(theta)
    bob_y = 0 + L * np.cos(theta)

    # ---------------- ГРАФИКИ ----------------
    fig, ax = plt.subplots(4, 1, figsize=(8, 10), sharex=True)

    ax[0].plot(t, x)
    ax[0].set_ylabel("x (м)")
    ax[0].grid(True)
    ax[0].set_title("Положение тележки")

    ax[1].plot(t, np.rad2deg(theta))
    ax[1].set_ylabel("θ (°)")
    ax[1].grid(True)
    ax[1].set_title("Угол маятника")

    ax[2].plot(t, F_ctrl_arr, label="управление")
    ax[2].plot(t, F_quake_arr, '--', label="землетрясение")
    ax[2].set_ylabel("F (Н)")
    ax[2].grid(True)
    ax[2].legend()
    ax[2].set_title("Силы")

    ax[3].plot(t, F_total_arr, label="итоговая сила")
    ax[3].set_ylabel("F (Н)")
    ax[3].set_xlabel("t (с)")
    ax[3].grid(True)
    ax[3].legend()

    plt.tight_layout()
    plt.show()

    # ---------------- АНИМАЦИЯ ----------------
    if not show_animation:
        return

    fig2, ax_a = plt.subplots(figsize=(9, 4))
    x_min = np.min(x) - 2.0
    x_max = np.max(x) + 2.0
    if x_min == x_max:
        x_min, x_max = -5, 5

    ax_a.set_xlim(x_min, x_max)
    ax_a.set_ylim(-2.0, 2.5)
    ax_a.set_xlabel("x (м)")
    ax_a.set_ylabel("y (м)")
    ax_a.set_title("Перевёрнутый маятник на тележке (с землетрясением)")
    ax_a.grid(True, linestyle=':')

    # линия земли
    ax_a.axhline(0, color='black', linewidth=1)

    cart_w, cart_h = 0.6, 0.3
    cart = plt.Rectangle((0, 0), cart_w, cart_h,
                         fc='none', ec='blue', linewidth=2)
    ax_a.add_patch(cart)

    rod, = ax_a.plot([], [], lw=3)
    bob_point, = ax_a.plot([], [], 'o', markersize=10)
    traj, = ax_a.plot([], [], '-', linewidth=1, alpha=0.7)

    text_info = ax_a.text(
        x_min + 0.1, 2.3, "",
        fontsize=9, va="top",
        bbox=dict(boxstyle="round", facecolor="white", alpha=0.9)
    )

    def init():
        rod.set_data([], [])
        bob_point.set_data([], [])
        traj.set_data([], [])
        text_info.set_text("")
        return rod, bob_point, cart, traj, text_info

    step = max(1, int(0.01 / dt))  # прореживание кадров
    frames = range(0, len(t), step)

    def update(i):
        xi = x[i]
        th = theta[i]

        cart_x = xi - cart_w/2
        cart_y = 0 - cart_h/2
        cart.set_xy((cart_x, cart_y))

        px, py = xi, 0.0
        bx, by = bob_x[i], bob_y[i]

        rod.set_data([px, bx], [py, by])
        bob_point.set_data([bx], [by])
        traj.set_data(bob_x[:i+1], bob_y[:i+1])

        status = "СТАБИЛЬНО" if abs(np.rad2deg(th)) < 15 and abs(theta_dot[i]) < 1.0 else "НЕСТАБИЛЬНО"

        text_info.set_text(
            "t = {:.2f} c\n"
            "θ = {:+.1f}°\n"
            "x = {:+.2f} м\n"
            "Статус: {}".format(t[i], np.rad2deg(th), xi, status)
        )
        return rod, bob_point, cart, traj, text_info

    anim = FuncAnimation(
        fig2, update, init_func=init,
        frames=frames, interval=1000*dt*step, blit=True
    )
    plt.close(fig2)
    display(HTML(anim.to_jshtml()))

# ================== ЗАПУСК СИМУЛЯЦИИ ==================
simulate_and_plot_cart_pole(
    mode='PD',          # управление включено
    theta0_deg=5,       # маятник чуть-чуть отклонён
    quake_on=True,      # включаем землетрясение
    quake_start=2.0,    # начало тряски
    quake_duration=1.5, # длительность тряски
    quake_amp=40.0,     # сила землетрясения
    quake_freq=5.0,     # частота
    quake_noise=10.0    # шум
)

# Commented out IPython magic to ensure Python compatibility.
# ================== ПЕРЕВЁРНУТЫЙ МАЯТНИК С ЗЕМЛЕТРЯСЕНИЕМ ==================
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import HTML
# %matplotlib inline

# --- параметры системы ---
M = 1.0
m = 0.1
L = 0.5
g = 9.81

# --- динамика ---
def f(state, F):
    x, x_dot, th, th_dot = state
    sin_t, cos_t = np.sin(th), np.cos(th)
    den = M + m * sin_t**2

    x_dd = (F + m*sin_t*(L*th_dot**2 + g*cos_t)) / den
    th_dd = (-F*cos_t - m*L*th_dot**2*cos_t*sin_t - (M+m)*g*sin_t) / (L*den)

    return np.array([x_dot, x_dd, th, th_dd])

# --- PD-контроллер ---
def PD(x, x_dot, th, th_dot):
    th_err = -th
    th_d_err = -th_dot
    x_err = -x
    x_d_err = -x_dot

    F = 60*th_err + 10*th_d_err + 2*x_err + 4*x_d_err
    return np.clip(F, -50, 50)

# --- симуляция ---
dt = 0.01
T = 10
N = int(T/dt)

state = np.zeros((N,4))
state[0] = [0, 0, np.deg2rad(8), 0]   # начальный угол 8°

t = np.linspace(0, T, N)

# параметры землетрясения
quake_start = 2.0
quake_end = 3.5
quake_amp = 40
quake_freq = 5

F_arr = []

for i in range(N-1):
    x, x_dot, th, th_dot = state[i]

    # управление
    F_ctrl = PD(x, x_dot, th, th_dot)

    # землетрясение
    if quake_start < t[i] < quake_end:
        tau = t[i] - quake_start
        F_quake = quake_amp * np.sin(2*np.pi*quake_freq*tau)
    else:
        F_quake = 0

    F = F_ctrl + F_quake
    F_arr.append(F)

    state[i+1] = state[i] + dt * f(state[i], F)

# координаты груза маятника
x = state[:,0]
th = state[:,2]
bx = x + L*np.sin(th)
by = 0 + L*np.cos(th)

# --- АНИМАЦИЯ ---
fig, ax = plt.subplots(figsize=(10,5))
ax.set_xlim(-3, 3)
ax.set_ylim(-1, 2.5)
ax.set_xlabel("x (м)")
ax.set_ylabel("y (м)")
ax.set_title("Перевёрнутый маятник на тележке (с землетрясением)")
ax.grid(True, linestyle=':')

# линия земли
ax.axhline(0, color='black')

# --- Синий прямоугольник-тележка ---
cart_w, cart_h = 0.6, 0.25
cart = plt.Rectangle(
    (0, 0), cart_w, cart_h,
    facecolor='blue',   # синий цвет заливки
    edgecolor='blue',   # синий контур
    linewidth=2
)
ax.add_patch(cart)

rod, = ax.plot([], [], lw=3, color='black')
bob, = ax.plot([], [], 'o', markersize=10, color='orange')
traj, = ax.plot([], [], '-', linewidth=1, alpha=0.7, color='green')

info = ax.text(
    -2.8, 2.3, "",
    fontsize=10, va='top',
    bbox=dict(boxstyle="round", facecolor="white", alpha=0.8)
)

def init():
    rod.set_data([], [])
    bob.set_data([], [])
    traj.set_data([], [])
    info.set_text("")
    return rod, bob, cart, traj, info

steps = range(0, N, 3)

def update(i):
    # позиция тележки
    cx = x[i] - cart_w/2
    cart.set_xy((cx, -cart_h/2))

    px = x[i]
    py = 0
    rod.set_data([px, bx[i]], [py, by[i]])
    bob.set_data([bx[i]], [by[i]])
    traj.set_data(bx[:i+1], by[:i+1])

    status = "СТАБИЛЬНО" if abs(np.rad2deg(th[i])) < 15 and abs(state[i,3]) < 1 else "НЕСТАБИЛЬНО"

    info.set_text(
        f"t = {t[i]:.2f} c\n"
        f"θ = {np.rad2deg(th[i]):+.1f}°\n"
        f"x = {x[i]:+.2f} м\n"
        f"Статус: {status}"
    )

    return rod, bob, cart, traj, info

anim = FuncAnimation(
    fig, update, frames=steps,
    init_func=init, interval=20, blit=True
)
plt.close(fig)
HTML(anim.to_jshtml())

# -*- coding: utf-8 -*-
# Тележка + перевёрнутый маятник
# НОРМАЛЬНОЕ отображение маятника + корректный CASCADE (PID не сбрасывается!)
# + вывод P/I/D составляющих отдельно (графики + в анимации)

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import HTML, display
import ipywidgets as widgets
from scipy.linalg import solve_continuous_are

# ---------- ПАРАМЕТРЫ СИСТЕМЫ ----------
M = 1.0
m = 0.2
L = 1.0
g = 9.81
mu = 0.05

def cart_pole_dynamics(state, F):
    """
    state = [x, x_dot, theta, theta_dot]
    theta=0 -> маятник вертикально вверх (стабилизация вокруг 0)
    """
    x, x_dot, theta, theta_dot = state
    sin_th = np.sin(theta)
    cos_th = np.cos(theta)

    total_mass = M + m
    temp = (F + m * L * theta_dot**2 * sin_th - mu * x_dot) / total_mass

    theta_ddot = (g * sin_th - cos_th * temp) / (
        L * (4.0/3.0 - m * cos_th**2 / total_mass)
    )
    x_ddot = temp - m * L * theta_ddot * cos_th / total_mass

    return np.array([x_dot, x_ddot, theta_dot, theta_ddot])

def linearized_system_matrices():
    total_mass = M + m
    A = np.array([
        [0, 1, 0, 0],
        [0, -mu/total_mass, -m*g/total_mass, 0],
        [0, 0, 0, 1],
        [0, -mu/(L*total_mass), (M+m)*g/(L*total_mass), 0]
    ])
    B = np.array([
        [0],
        [1/total_mass],
        [0],
        [1/(L*total_mass)]
    ])
    return A, B

def compute_lqr_gain(Q_diag, R_val):
    A, B = linearized_system_matrices()
    Q = np.diag(Q_diag)
    R = np.array([[R_val]])
    try:
        P = solve_continuous_are(A, B, Q, R)
        K = np.linalg.inv(R) @ B.T @ P
        return K.flatten(), True
    except Exception as e:
        print("LQR решение не найдено, используем эвристические коэффициенты")
        return np.array([-2.0, -3.0, -50.0, -10.0]), False

def angle_wrap(theta):
    return (theta + np.pi) % (2*np.pi) - np.pi

# ---------- КОНТРОЛЛЕРЫ ----------
class PIDController:
    """PID для позиции тележки: возвращает u и разложение на P/I/D"""
    def __init__(self, Kp, Ki, Kd, max_output, dt, integral_limit=None):
        self.Kp = Kp
        self.Ki = Ki
        self.Kd = Kd
        self.max_output = max_output
        self.dt = dt
        self.integral = 0.0
        self.prev_error = 0.0
        self.integral_limit = integral_limit

    def reset(self):
        self.integral = 0.0
        self.prev_error = 0.0

    def update(self, error):
        # интеграл
        self.integral += error * self.dt
        if self.integral_limit is not None:
            self.integral = np.clip(self.integral, -self.integral_limit, self.integral_limit)

        # производная
        derivative = (error - self.prev_error) / self.dt if self.dt > 0 else 0.0
        self.prev_error = error

        P = self.Kp * error
        I = self.Ki * self.integral
        D = self.Kd * derivative
        u = P + I + D
        u_sat = float(np.clip(u, -self.max_output, self.max_output))

        # простой anti-windup: если ушли в насыщение — чуть поджимаем интеграл
        if u != u_sat and self.Ki != 0:
            self.integral *= 0.98

        return u_sat, P, I, D, self.integral

def controller_PD(x, x_dot, theta, theta_dot,
                  x_ref, theta_ref,
                  Kp_theta, Kd_theta, Kp_x, Kd_x, F_max):
    e_theta = angle_wrap(theta_ref - theta)
    e_x = x_ref - x
    F = (Kp_theta * e_theta +
         Kd_theta * (0.0 - theta_dot) +
         Kp_x * e_x +
         Kd_x * (0.0 - x_dot))
    return float(np.clip(F, -F_max, F_max))

def controller_DOG(x, x_dot, theta, theta_dot,
                   x_ref, theta_ref,
                   Kp_theta, Kd_theta, Kp_x, Kd_x, F_max):
    e_theta = angle_wrap(theta_ref - theta)
    e_x = x_ref - x
    F = (Kp_theta * np.tanh(2.0 * e_theta) +
         Kd_theta * np.tanh(-theta_dot/2.0) +
         Kp_x * np.tanh(e_x/5.0) +
         Kd_x * np.tanh(-x_dot/2.0))
    return float(np.clip(F, -F_max, F_max))

def controller_LQR(x, x_dot, theta, theta_dot,
                   x_ref, theta_ref, K, F_max):
    theta_error = angle_wrap(theta_ref - theta)
    x_error = x_ref - x
    state_error = np.array([x_error, -x_dot, theta_error, -theta_dot])
    F = -np.dot(K, state_error)
    return float(np.clip(F, -F_max, F_max))

# ---------- СИМУЛЯЦИЯ + ВИЗУАЛИЗАЦИЯ ----------
def simulate_and_plot_cart_pole(
    mode='CASCADE',
    x_ref=5.0,
    theta_ref_deg=0.0,
    x0=0.0,
    xdot0=0.0,
    theta0_deg=10.0,
    thetadot0=0.0,
    Kp_theta=80.0,
    Kd_theta=15.0,
    Kp_x=1.5,
    Kd_x=3.0,
    F_max=100.0,
    # LQR
    Q_xx=0.5,
    Q_xd=0.05,
    Q_theta=300.0,
    Q_thetad=20.0,
    R_val=0.1,
    # PID позиции (в каскаде)
    pos_Kp=0.5,
    pos_Ki=0.05,
    pos_Kd=1.0,
    T=20.0,
    dt=0.01,
    show_animation=True,
    track_length=20.0
):
    plt.close('all')

    theta_ref = np.deg2rad(theta_ref_deg)
    theta0 = np.deg2rad(theta0_deg)

    N = int(T / dt)
    t = np.linspace(0, T, N)

    state = np.zeros((N, 4))
    state[0] = [x0, xdot0, theta0, thetadot0]
    F_arr = np.zeros(N)

    # Для каскада: theta_desired + PID составляющие
    theta_desired_arr = np.zeros(N)
    pid_P_arr = np.zeros(N)
    pid_I_arr = np.zeros(N)
    pid_D_arr = np.zeros(N)
    pid_u_arr = np.zeros(N)
    pid_int_arr = np.zeros(N)

    # LQR коэффициенты
    K_lqr = None
    if mode in ['LQR', 'CASCADE']:
        Q_diag = [Q_xx, Q_xd, Q_theta, Q_thetad]
        K_lqr, success = compute_lqr_gain(Q_diag, R_val)
        print("K:", np.round(K_lqr, 3), "| success:", success)

    # ВАЖНО: PID должен жить вне цикла, иначе интеграл всегда = 0
    pos_pid = None
    if mode == 'CASCADE':
        pos_pid = PIDController(
            pos_Kp, pos_Ki, pos_Kd,
            max_output=np.deg2rad(30),  # максимум требуемого наклона (рад)
            dt=dt,
            integral_limit=50.0
        )

    for k in range(N - 1):
        x, x_dot, theta, theta_dot = state[k]

        if mode == 'Off':
            F = 0.0

        elif mode == 'PD':
            F = controller_PD(x, x_dot, theta, theta_dot, x_ref, theta_ref,
                              Kp_theta, Kd_theta, Kp_x, Kd_x, F_max)

        elif mode == 'Dog':
            F = controller_DOG(x, x_dot, theta, theta_dot, x_ref, theta_ref,
                               Kp_theta, Kd_theta, Kp_x, Kd_x, F_max)

        elif mode == 'LQR':
            F = controller_LQR(x, x_dot, theta, theta_dot, x_ref, theta_ref, K_lqr, F_max)

        elif mode == 'CASCADE':
            # Внешний контур (позиция) -> желаемый угол
            e_x = x_ref - x
            u_pid, P, I, D, integ = pos_pid.update(e_x)
            theta_desired = float(np.clip(u_pid, np.deg2rad(-30), np.deg2rad(30)))

            theta_desired_arr[k] = theta_desired
            pid_u_arr[k] = u_pid
            pid_P_arr[k] = P
            pid_I_arr[k] = I
            pid_D_arr[k] = D
            pid_int_arr[k] = integ

            # Внутренний контур (стабилизация маятника)
            if K_lqr is not None:
                F = controller_LQR(x, x_dot, theta, theta_dot, x_ref, theta_desired, K_lqr, F_max)
            else:
                F = controller_PD(x, x_dot, theta, theta_dot, x_ref, theta_desired,
                                  Kp_theta, Kd_theta, 0, 0, F_max)
        else:
            F = 0.0

        F_arr[k] = F
        state[k+1] = state[k] + dt * cart_pole_dynamics(state[k], F)

    x = state[:, 0]
    theta = state[:, 2]
    theta_dot = state[:, 3]

    # координаты груза (pivot — верх тележки)
    cart_h = 0.8
    pivot_y = cart_h/2  # верх тележки
    bob_x_all = x + L * np.sin(theta)
    bob_y_all = pivot_y + L * np.cos(theta)

    # ---------- ГРАФИКИ ----------
    if mode == 'CASCADE':
        fig1, ax = plt.subplots(5, 1, figsize=(11, 12), sharex=True)
    else:
        fig1, ax = plt.subplots(4, 1, figsize=(11, 10), sharex=True)

    ax[0].plot(t, x, label='x(t)', linewidth=2)
    ax[0].axhline(x_ref, linestyle='--', color='k', label='x_ref', linewidth=2)
    ax[0].axhline(track_length/2, linestyle=':', color='gray', alpha=0.5)
    ax[0].axhline(-track_length/2, linestyle=':', color='gray', alpha=0.5)
    ax[0].fill_between(t, -track_length/2, track_length/2, alpha=0.08)
    ax[0].set_ylabel("x, м")
    ax[0].grid(True, alpha=0.3)
    ax[0].legend(loc='upper right')
    ax[0].set_ylim(-track_length/2-1, track_length/2+1)

    ax[1].plot(t, np.rad2deg(theta), label='θ(t)', linewidth=2)
    ax[1].axhline(theta_ref_deg, linestyle='--', color='k', label='θ_ref', linewidth=2)
    if mode == 'CASCADE':
        ax[1].plot(t, np.rad2deg(theta_desired_arr), '--', label='θ_desired', alpha=0.8)
    ax[1].axhline(30, linestyle=':', alpha=0.5)
    ax[1].axhline(-30, linestyle=':', alpha=0.5)
    ax[1].set_ylabel("θ, °")
    ax[1].grid(True, alpha=0.3)
    ax[1].legend(loc='upper right')
    ax[1].set_ylim(-45, 45)

    ax[2].plot(t, F_arr, label='F(t)', linewidth=2)
    ax[2].axhline(F_max, linestyle='--', linewidth=1, alpha=0.7, label='±F_max')
    ax[2].axhline(-F_max, linestyle='--', linewidth=1, alpha=0.7)
    ax[2].fill_between(t, -F_max, F_max, alpha=0.08)
    ax[2].set_ylabel("F, Н")
    ax[2].grid(True, alpha=0.3)
    ax[2].legend(loc='upper right')

    ax[3].plot(t, state[:, 1], label='x_dot', linewidth=1.5)
    ax[3].plot(t, state[:, 3], label='theta_dot', linewidth=1.5)
    ax[3].set_ylabel("скорости")
    ax[3].grid(True, alpha=0.3)
    ax[3].legend(loc='upper right')
    ax[-1].set_xlabel("t, c")

    if mode == 'CASCADE':
        ax[4].plot(t, pid_P_arr, label='PID P', linewidth=1.5)
        ax[4].plot(t, pid_I_arr, label='PID I', linewidth=1.5)
        ax[4].plot(t, pid_D_arr, label='PID D', linewidth=1.5)
        ax[4].plot(t, pid_u_arr, label='PID u (θ_des before clip)', linewidth=1.0, alpha=0.7)
        ax[4].set_ylabel("PID (рад)")
        ax[4].grid(True, alpha=0.3)
        ax[4].legend(loc='upper right')

    fig1.suptitle(f"Cart-Pole | mode={mode} | x_ref={x_ref} м | track={track_length} м")
    plt.tight_layout()
    plt.show()

    # ---------- АНИМАЦИЯ (НОРМАЛЬНОЕ отображение) ----------
    if show_animation:
        fig, axa = plt.subplots(figsize=(12, 6))

        x_min_view = min(np.min(x) - 3.0, -track_length/2 - 2.0)
        x_max_view = max(np.max(x) + 3.0,  track_length/2 + 2.0)

        axa.set_xlim(x_min_view, x_max_view)
        axa.set_ylim(-1.5, 3.5)
        axa.set_xlabel("x, м")
        axa.set_ylabel("y, м")

        # трек + границы
        axa.axhline(0, color="gray", linewidth=2)
        axa.axvline(-track_length/2, color='black', linewidth=3)
        axa.axvline(track_length/2, color='black', linewidth=3)
        axa.fill_between([x_min_view, x_max_view], -1.5, 0, alpha=0.07)

        axa.grid(True, linestyle=":", linewidth=0.5, alpha=0.5)
        axa.set_title(f"Перевёрнутый маятник | {mode} | трек ±{track_length/2} м")

        # тележка (центр в x)
        cart_w, cart_h = 1.5, 0.8
        cart = plt.Rectangle((0, 0), cart_w, cart_h, fc="lightblue", ec="blue", linewidth=2, alpha=0.9)
        axa.add_patch(cart)

        # колёса (чисто визуально)
        wheel1, = axa.plot([], [], 'o', markersize=10)
        wheel2, = axa.plot([], [], 'o', markersize=10)

        # маятник
        rod, = axa.plot([], [], lw=4, alpha=0.9)
        bob, = axa.plot([], [], 'o', markersize=16)

        # траектория груза
        traj, = axa.plot([], [], '-', linewidth=1, alpha=0.35)

        # цель
        target_line = axa.axvline(x_ref, linestyle='--', linewidth=2, alpha=0.8)

        # подписи
        text_box = axa.text(
            0.02, 0.98, "",
            fontsize=10, va="top", transform=axa.transAxes,
            bbox=dict(boxstyle="round", facecolor="white", alpha=0.9)
        )

        # кадровая дискретизация
        step = max(1, int(0.02 / dt))        # ~50 FPS по данным
        frame_idx = np.arange(0, N, step)    # реальные индексы массива

        def init():
            rod.set_data([], [])
            bob.set_data([], [])
            traj.set_data([], [])
            wheel1.set_data([], [])
            wheel2.set_data([], [])
            text_box.set_text("")
            return rod, bob, cart, traj, target_line, text_box, wheel1, wheel2

        def update(frame_number):
            k = frame_idx[frame_number]
            xi = x[k]
            th = theta[k]

            # тележка
            cart_x = xi - cart_w/2
            cart_y = -cart_h/2
            cart.set_xy((cart_x, cart_y))

            # колёса
            wx1, wy = xi - cart_w*0.30, -cart_h/2
            wx2, wy2 = xi + cart_w*0.30, -cart_h/2
            wheel1.set_data([wx1], [wy])
            wheel2.set_data([wx2], [wy2])

            # pivot (верх тележки)
            px, py = xi, pivot_y

            # груз
            bx = bob_x_all[k]
            by = bob_y_all[k]

            rod.set_data([px, bx], [py, by])
            bob.set_data([bx], [by])

            # траектория груза (последние 150 точек)
            start = max(0, k - 150*step)
            traj.set_data(bob_x_all[start:k+1], bob_y_all[start:k+1])

            # цель
            target_line.set_xdata([x_ref, x_ref])

            # статус + PID (если есть)
            angle_err = abs(np.rad2deg(angle_wrap(th - theta_ref)))
            pos_err = abs(xi - x_ref)

            if angle_err < 5.0 and pos_err < 0.5 and abs(theta_dot[k]) < 0.5:
                status = "СТАБИЛЬНО ✓"
            elif angle_err < 15.0:
                status = "СТАБИЛИЗИРУЕТСЯ"
            else:
                status = "НЕСТАБИЛЬНО"

            lines = [
                f"t = {t[k]:.2f} c",
                f"x = {xi:.2f} м | x_err = {xi-x_ref:+.2f} м",
                f"θ = {np.rad2deg(th):+.1f}° | θ_err = {angle_err:.1f}°",
                f"F = {F_arr[k]:+.1f} Н",
                f"{status}"
            ]

            if mode == 'CASCADE':
                lines.append(f"PID: P={pid_P_arr[k]:+.3f}, I={pid_I_arr[k]:+.3f}, D={pid_D_arr[k]:+.3f} (рад)")
                lines.append(f"θ_des = {np.rad2deg(theta_desired_arr[k]):+.1f}°")

            text_box.set_text("\n".join(lines))

            return rod, bob, cart, traj, target_line, text_box, wheel1, wheel2

        anim = FuncAnimation(
            fig, update, init_func=init,
            frames=len(frame_idx),
            interval=1000 * dt * step,
            blit=True
        )

        plt.close(fig)
        display(HTML(anim.to_jshtml()))

    # ---------- СТАТИСТИКА ----------
    print(f"\n{'='*60}")
    print(f"СТАТИСТИКА ({mode}) | трек ±{track_length/2} м | цель {x_ref} м")
    print(f"{'='*60}")
    print(f"Макс |θ|: {np.max(np.abs(np.rad2deg(theta))):.1f}°")
    print(f"Макс |F|: {np.max(np.abs(F_arr)):.1f} Н")
    print(f"Макс |x_dot|: {np.max(np.abs(state[:,1])):.2f} м/с")
    print(f"Путь: {np.sum(np.abs(np.diff(x))):.1f} м")

    final_pos_error = abs(x[-1] - x_ref)
    final_angle_error = abs(np.rad2deg(angle_wrap(theta[-1] - theta_ref)))
    print(f"Финальная ошибка: x={final_pos_error:.3f} м, θ={final_angle_error:.2f}°")

    if mode != 'Off':
        IAE_angle = np.trapz(np.abs(theta), t)
        IAE_position = np.trapz(np.abs(x - x_ref), t)
        print(f"IAE(угол): {IAE_angle:.2f} рад·с | IAE(позиция): {IAE_position:.2f} м·с")


# ---------- ВИДЖЕТЫ ДЛЯ COLAB ----------
mode_widget = widgets.Dropdown(
    options=[('Off','Off'),
             ('PD','PD'),
             ('Dog (пастушья)','Dog'),
             ('LQR','LQR'),
             ('Каскадный (рекомендуется)','CASCADE')],
    value='CASCADE',
    description='Режим:'
)

x_ref_widget = widgets.FloatSlider(value=5.0, min=-10, max=10, step=0.5,
                                   description='x_ref (м):', continuous_update=False,
                                   style={'description_width': 'initial'})
track_length_widget = widgets.FloatSlider(value=20.0, min=10, max=50, step=5,
                                          description='Длина трека (м):', continuous_update=False,
                                          style={'description_width': 'initial'})
theta_ref_widget = widgets.FloatSlider(value=0.0, min=-30, max=30, step=1,
                                       description='θ_ref (°):', continuous_update=False)

x0_widget = widgets.FloatSlider(value=0.0, min=-5, max=5, step=0.5,
                                description='x0 (м):', continuous_update=False)
xdot0_widget = widgets.FloatSlider(value=0.0, min=-5, max=5, step=0.1,
                                   description='ẋ0 (м/с):', continuous_update=False)

theta0_widget = widgets.FloatSlider(value=15.0, min=-60, max=60, step=5,
                                    description='θ0 (°):', continuous_update=False,
                                    style={'description_width': 'initial'})
thetadot0_widget = widgets.FloatSlider(value=0.0, min=-10, max=10, step=0.1,
                                       description='θ̇0 (рад/с):', continuous_update=False)

Kp_theta_widget = widgets.FloatSlider(value=80.0, min=10, max=200, step=5,
                                      description='Kθ_p:', continuous_update=False)
Kd_theta_widget = widgets.FloatSlider(value=15.0, min=1, max=50, step=1,
                                      description='Kθ_d:', continuous_update=False)

Kp_x_widget = widgets.FloatSlider(value=1.5, min=0.1, max=5.0, step=0.1,
                                  description='Kx_p:', continuous_update=False)
Kd_x_widget = widgets.FloatSlider(value=3.0, min=0.1, max=10.0, step=0.1,
                                  description='Kx_d:', continuous_update=False)

Q_xx_widget = widgets.FloatSlider(value=0.5, min=0.1, max=5.0, step=0.1,
                                  description='Q_xx:', continuous_update=False)
Q_xd_widget = widgets.FloatSlider(value=0.05, min=0.01, max=0.5, step=0.01,
                                  description='Q_xd:', continuous_update=False)
Q_theta_widget = widgets.FloatSlider(value=300.0, min=50, max=1000, step=50,
                                     description='Q_θ:', continuous_update=False)
Q_thetad_widget = widgets.FloatSlider(value=20.0, min=5, max=100, step=5,
                                      description='Q_θd:', continuous_update=False)
R_widget = widgets.FloatSlider(value=0.1, min=0.01, max=1, step=0.01,
                               description='R:', continuous_update=False)

pos_Kp_widget = widgets.FloatSlider(value=0.5, min=0.1, max=2.0, step=0.1,
                                    description='Pos_Kp:', continuous_update=False)
pos_Ki_widget = widgets.FloatSlider(value=0.05, min=0.0, max=0.2, step=0.01,
                                    description='Pos_Ki:', continuous_update=False)
pos_Kd_widget = widgets.FloatSlider(value=1.0, min=0.0, max=5.0, step=0.1,
                                    description='Pos_Kd:', continuous_update=False)

F_max_widget = widgets.FloatSlider(value=100.0, min=20, max=200, step=10,
                                   description='F_max (Н):', continuous_update=False,
                                   style={'description_width': 'initial'})
T_widget = widgets.FloatSlider(value=20.0, min=5, max=60, step=5,
                               description='Время (с):', continuous_update=False)
dt_widget = widgets.FloatLogSlider(value=0.01, base=10, min=-3, max=-1,
                                   description='dt:', continuous_update=False)
show_anim_widget = widgets.Checkbox(value=True, description='Анимация')

from ipywidgets import Accordion

basic_tab = widgets.VBox([
    widgets.HTML("<h4>Основные настройки</h4>"),
    widgets.HBox([x_ref_widget, track_length_widget]),
    widgets.HBox([theta_ref_widget, F_max_widget]),
    widgets.HBox([x0_widget, theta0_widget]),
    widgets.HBox([xdot0_widget, thetadot0_widget]),
    widgets.HBox([T_widget, dt_widget]),
    show_anim_widget
])

pd_tab = widgets.VBox([
    widgets.HTML("<h4>PD / Dog</h4>"),
    widgets.HBox([Kp_theta_widget, Kd_theta_widget]),
    widgets.HBox([Kp_x_widget, Kd_x_widget]),
])

lqr_tab = widgets.VBox([
    widgets.HTML("<h4>LQR</h4>"),
    widgets.HBox([Q_xx_widget, Q_xd_widget]),
    widgets.HBox([Q_theta_widget, Q_thetad_widget]),
    R_widget
])

cascade_tab = widgets.VBox([
    widgets.HTML("<h4>Каскад (позиция -> θ_des)</h4>"),
    widgets.HBox([pos_Kp_widget, pos_Ki_widget]),
    pos_Kd_widget
])

accordion = Accordion(children=[basic_tab, pd_tab, lqr_tab, cascade_tab])
accordion.set_title(0, 'Основные')
accordion.set_title(1, 'PD/Dog')
accordion.set_title(2, 'LQR')
accordion.set_title(3, 'CASCADE (PID)')

controls = widgets.VBox([mode_widget, widgets.HTML("<hr>"), accordion])

out = widgets.interactive_output(
    simulate_and_plot_cart_pole,
    dict(
        mode=mode_widget,
        x_ref=x_ref_widget,
        theta_ref_deg=theta_ref_widget,
        x0=x0_widget,
        xdot0=xdot0_widget,
        theta0_deg=theta0_widget,
        thetadot0=thetadot0_widget,
        Kp_theta=Kp_theta_widget,
        Kd_theta=Kd_theta_widget,
        Kp_x=Kp_x_widget,
        Kd_x=Kd_x_widget,
        F_max=F_max_widget,
        Q_xx=Q_xx_widget,
        Q_xd=Q_xd_widget,
        Q_theta=Q_theta_widget,
        Q_thetad=Q_thetad_widget,
        R_val=R_widget,
        pos_Kp=pos_Kp_widget,
        pos_Ki=pos_Ki_widget,
        pos_Kd=pos_Kd_widget,
        T=T_widget,
        dt=dt_widget,
        show_animation=show_anim_widget,
        track_length=track_length_widget
    )
)

display(controls, out)

# -*- coding: utf-8 -*-
# Cart-Pole (тележка + перевёрнутый маятник)
# ✅ Нормальная геометрия анимации (aspect='equal')
# ✅ Траектория ВЕРХНЕЙ точки (груза)
# ✅ Траектория точки крепления (верх тележки)
# ✅ CASCADE: PID не пересоздаётся каждый шаг (интеграл живёт корректно)
# ✅ Вывод значений строчками с обозначениями, подписями и единицами

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import HTML, display
import ipywidgets as widgets
from scipy.linalg import solve_continuous_are
from ipywidgets import Accordion

# ---------- ПАРАМЕТРЫ СИСТЕМЫ ----------
M = 1.0
m = 0.2
L = 1.0
g = 9.81
mu = 0.05

def cart_pole_dynamics(state, F):
    """
    state = [x, x_dot, theta, theta_dot]
    theta=0 -> маятник вертикально вверх (стабилизация вокруг 0)
    """
    x, x_dot, theta, theta_dot = state
    sin_th = np.sin(theta)
    cos_th = np.cos(theta)

    total_mass = M + m
    temp = (F + m * L * theta_dot**2 * sin_th - mu * x_dot) / total_mass

    theta_ddot = (g * sin_th - cos_th * temp) / (
        L * (4.0/3.0 - m * cos_th**2 / total_mass)
    )
    x_ddot = temp - m * L * theta_ddot * cos_th / total_mass

    return np.array([x_dot, x_ddot, theta_dot, theta_ddot])

def linearized_system_matrices():
    total_mass = M + m
    A = np.array([
        [0, 1, 0, 0],
        [0, -mu/total_mass, -m*g/total_mass, 0],
        [0, 0, 0, 1],
        [0, -mu/(L*total_mass), (M+m)*g/(L*total_mass), 0]
    ])
    B = np.array([
        [0],
        [1/total_mass],
        [0],
        [1/(L*total_mass)]
    ])
    return A, B

def compute_lqr_gain(Q_diag, R_val):
    A, B = linearized_system_matrices()
    Q = np.diag(Q_diag)
    R = np.array([[R_val]])
    try:
        P = solve_continuous_are(A, B, Q, R)
        K = np.linalg.inv(R) @ B.T @ P
        return K.flatten(), True
    except Exception:
        print("LQR решение не найдено, используем эвристические коэффициенты")
        return np.array([-2.0, -3.0, -50.0, -10.0]), False

def angle_wrap(theta):
    return (theta + np.pi) % (2*np.pi) - np.pi

# ---------- КОНТРОЛЛЕРЫ ----------
class PIDController:
    """PID: возвращает u и разложение на P/I/D"""
    def __init__(self, Kp, Ki, Kd, max_output, dt, integral_limit=None):
        self.Kp = Kp
        self.Ki = Ki
        self.Kd = Kd
        self.max_output = max_output
        self.dt = dt
        self.integral = 0.0
        self.prev_error = 0.0
        self.integral_limit = integral_limit

    def reset(self):
        self.integral = 0.0
        self.prev_error = 0.0

    def update(self, error):
        self.integral += error * self.dt
        if self.integral_limit is not None:
            self.integral = np.clip(self.integral, -self.integral_limit, self.integral_limit)

        derivative = (error - self.prev_error) / self.dt if self.dt > 0 else 0.0
        self.prev_error = error

        P = self.Kp * error
        I = self.Ki * self.integral
        D = self.Kd * derivative
        u = P + I + D
        u_sat = float(np.clip(u, -self.max_output, self.max_output))

        # простой anti-windup
        if u != u_sat and self.Ki != 0:
            self.integral *= 0.98

        return u_sat, P, I, D, self.integral

def controller_PD(x, x_dot, theta, theta_dot,
                  x_ref, theta_ref,
                  Kp_theta, Kd_theta, Kp_x, Kd_x, F_max):
    e_theta = angle_wrap(theta_ref - theta)
    e_x = x_ref - x
    F = (Kp_theta * e_theta +
         Kd_theta * (0.0 - theta_dot) +
         Kp_x * e_x +
         Kd_x * (0.0 - x_dot))
    return float(np.clip(F, -F_max, F_max))

def controller_DOG(x, x_dot, theta, theta_dot,
                   x_ref, theta_ref,
                   Kp_theta, Kd_theta, Kp_x, Kd_x, F_max):
    e_theta = angle_wrap(theta_ref - theta)
    e_x = x_ref - x
    F = (Kp_theta * np.tanh(2.0 * e_theta) +
         Kd_theta * np.tanh(-theta_dot/2.0) +
         Kp_x * np.tanh(e_x/5.0) +
         Kd_x * np.tanh(-x_dot/2.0))
    return float(np.clip(F, -F_max, F_max))

def controller_LQR(x, x_dot, theta, theta_dot,
                   x_ref, theta_ref, K, F_max):
    theta_error = angle_wrap(theta_ref - theta)
    x_error = x_ref - x
    state_error = np.array([x_error, -x_dot, theta_error, -theta_dot])
    F = -np.dot(K, state_error)
    return float(np.clip(F, -F_max, F_max))

# ---------- СИМУЛЯЦИЯ + ВИЗУАЛИЗАЦИЯ ----------
def simulate_and_plot_cart_pole(
    mode='CASCADE',
    x_ref=5.0,
    theta_ref_deg=0.0,
    x0=0.0,
    xdot0=0.0,
    theta0_deg=10.0,
    thetadot0=0.0,
    Kp_theta=80.0,
    Kd_theta=15.0,
    Kp_x=1.5,
    Kd_x=3.0,
    F_max=100.0,
    # LQR
    Q_xx=0.5,
    Q_xd=0.05,
    Q_theta=300.0,
    Q_thetad=20.0,
    R_val=0.1,
    # PID позиции
    pos_Kp=0.5,
    pos_Ki=0.05,
    pos_Kd=1.0,
    T=20.0,
    dt=0.01,
    show_animation=True,
    track_length=20.0
):
    plt.close('all')

    theta_ref = np.deg2rad(theta_ref_deg)
    theta0 = np.deg2rad(theta0_deg)

    N = int(T / dt)
    t = np.linspace(0, T, N)

    state = np.zeros((N, 4))
    state[0] = [x0, xdot0, theta0, thetadot0]
    F_arr = np.zeros(N)

    theta_desired_arr = np.zeros(N)
    pid_P_arr = np.zeros(N)
    pid_I_arr = np.zeros(N)
    pid_D_arr = np.zeros(N)
    pid_u_arr = np.zeros(N)
    pid_int_arr = np.zeros(N)

    # LQR
    K_lqr = None
    if mode in ['LQR', 'CASCADE']:
        Q_diag = [Q_xx, Q_xd, Q_theta, Q_thetad]
        K_lqr, success = compute_lqr_gain(Q_diag, R_val)
        if success:
            print(f"LQR K = [{K_lqr[0]:.3f}, {K_lqr[1]:.3f}, {K_lqr[2]:.3f}, {K_lqr[3]:.3f}]")
        else:
            print(f"Эвристический K = [{K_lqr[0]:.3f}, {K_lqr[1]:.3f}, {K_lqr[2]:.3f}, {K_lqr[3]:.3f}]")

    # ВАЖНО: PID создаём ОДИН раз
    pos_pid = None
    if mode == 'CASCADE':
        pos_pid = PIDController(
            pos_Kp, pos_Ki, pos_Kd,
            max_output=np.deg2rad(30),
            dt=dt,
            integral_limit=50.0
        )

    for k in range(N - 1):
        x, x_dot, theta, theta_dot = state[k]

        if mode == 'Off':
            F = 0.0

        elif mode == 'PD':
            F = controller_PD(x, x_dot, theta, theta_dot, x_ref, theta_ref,
                              Kp_theta, Kd_theta, Kp_x, Kd_x, F_max)

        elif mode == 'Dog':
            F = controller_DOG(x, x_dot, theta, theta_dot, x_ref, theta_ref,
                               Kp_theta, Kd_theta, Kp_x, Kd_x, F_max)

        elif mode == 'LQR':
            F = controller_LQR(x, x_dot, theta, theta_dot, x_ref, theta_ref, K_lqr, F_max)

        elif mode == 'CASCADE':
            e_x = x_ref - x
            u_pid, P, I, D, integ = pos_pid.update(e_x)
            theta_desired = float(np.clip(u_pid, np.deg2rad(-30), np.deg2rad(30)))

            theta_desired_arr[k] = theta_desired
            pid_u_arr[k] = u_pid
            pid_P_arr[k] = P
            pid_I_arr[k] = I
            pid_D_arr[k] = D
            pid_int_arr[k] = integ

            if K_lqr is not None:
                F = controller_LQR(x, x_dot, theta, theta_dot, x_ref, theta_desired, K_lqr, F_max)
            else:
                F = controller_PD(x, x_dot, theta, theta_dot, x_ref, theta_desired,
                                  Kp_theta, Kd_theta, 0, 0, F_max)
        else:
            F = 0.0

        F_arr[k] = F
        state[k+1] = state[k] + dt * cart_pole_dynamics(state[k], F)

    x = state[:, 0]
    theta = state[:, 2]
    theta_dot = state[:, 3]

    # ---------- ГРАФИКИ ----------
    if mode == 'CASCADE':
        fig1, ax = plt.subplots(5, 1, figsize=(11, 12), sharex=True)
    else:
        fig1, ax = plt.subplots(4, 1, figsize=(11, 10), sharex=True)

    ax[0].plot(t, x, label='x(t)', linewidth=2)
    ax[0].axhline(x_ref, linestyle='--', color='k', label='x_ref', linewidth=2)
    ax[0].axhline(track_length/2, linestyle=':', color='gray', alpha=0.5)
    ax[0].axhline(-track_length/2, linestyle=':', color='gray', alpha=0.5)
    ax[0].fill_between(t, -track_length/2, track_length/2, alpha=0.08)
    ax[0].set_ylabel("x, м")
    ax[0].grid(True, alpha=0.3)
    ax[0].legend(loc='upper right')
    ax[0].set_ylim(-track_length/2-1, track_length/2+1)

    ax[1].plot(t, np.rad2deg(theta), label='θ(t)', linewidth=2)
    ax[1].axhline(theta_ref_deg, linestyle='--', color='k', label='θ_ref', linewidth=2)
    if mode == 'CASCADE':
        ax[1].plot(t, np.rad2deg(theta_desired_arr), '--', label='θ_desired', alpha=0.8)
    ax[1].axhline(30, linestyle=':', alpha=0.5)
    ax[1].axhline(-30, linestyle=':', alpha=0.5)
    ax[1].set_ylabel("θ, °")
    ax[1].grid(True, alpha=0.3)
    ax[1].legend(loc='upper right')
    ax[1].set_ylim(-45, 45)

    ax[2].plot(t, F_arr, label='F(t)', linewidth=2)
    ax[2].axhline(F_max, linestyle='--', linewidth=1, alpha=0.7, label='±F_max')
    ax[2].axhline(-F_max, linestyle='--', linewidth=1, alpha=0.7)
    ax[2].fill_between(t, -F_max, F_max, alpha=0.08)
    ax[2].set_ylabel("F, Н")
    ax[2].grid(True, alpha=0.3)
    ax[2].legend(loc='upper right')

    ax[3].plot(t, state[:, 1], label='x_dot', linewidth=1.5)
    ax[3].plot(t, state[:, 3], label='theta_dot', linewidth=1.5)
    ax[3].set_ylabel("скорости")
    ax[3].grid(True, alpha=0.3)
    ax[3].legend(loc='upper right')
    ax[-1].set_xlabel("t, c")

    if mode == 'CASCADE':
        ax[4].plot(t, pid_P_arr, label='PID P', linewidth=1.5)
        ax[4].plot(t, pid_I_arr, label='PID I', linewidth=1.5)
        ax[4].plot(t, pid_D_arr, label='PID D', linewidth=1.5)
        ax[4].plot(t, pid_u_arr, label='PID u (до clip)', linewidth=1.0, alpha=0.7)
        ax[4].set_ylabel("PID (рад)")
        ax[4].grid(True, alpha=0.3)
        ax[4].legend(loc='upper right')

    fig1.suptitle(f"Cart-Pole | mode={mode} | x_ref={x_ref} м | track={track_length} м")
    plt.tight_layout()
    plt.show()

    # ---------- АНИМАЦИЯ (НОРМАЛЬНО + ТРАЕКТОРИЯ ВЕРХНЕЙ ТОЧКИ) ----------
    if show_animation:
        fig, axa = plt.subplots(figsize=(12, 6))

        x_min_view = min(np.min(x) - 3.0, -track_length/2 - 2.0)
        x_max_view = max(np.max(x) + 3.0,  track_length/2 + 2.0)

        axa.set_xlim(x_min_view, x_max_view)
        axa.set_ylim(-1.5, 3.0)
        axa.set_xlabel("x, м")
        axa.set_ylabel("y, м")
        axa.set_aspect('equal', adjustable='box')  # <--- важно для "нормального" маятника

        axa.axhline(0, color="black", linewidth=2)
        axa.axvline(-track_length/2, color='black', linewidth=3)
        axa.axvline(track_length/2, color='black', linewidth=3)
        axa.grid(True, linestyle=":", linewidth=0.5, alpha=0.5)
        axa.set_title(f"Перевёрнутый маятник | {mode} | трек ±{track_length/2} м")

        # тележка
        cart_w, cart_h = 1.5, 0.8
        cart = plt.Rectangle((0, 0), cart_w, cart_h, fc="blue", ec="blue", linewidth=2, alpha=0.9)
        axa.add_patch(cart)

        # маятник
        rod, = axa.plot([], [], lw=4, color='black', alpha=0.9)
        bob, = axa.plot([], [], 'o', color='orange', markersize=10)

        # траектории
        top_traj, = axa.plot([], [], '-', color='orange', linewidth=1.5, alpha=0.55)  # верхняя точка
        pivot_traj, = axa.plot([], [], '-', color='black', linewidth=1.0, alpha=0.25) # точка крепления

        # цель
        target_line = axa.axvline(x_ref, color='green', linestyle='--', linewidth=2, alpha=0.8)

        # текстовый блок
        text_box = axa.text(
            0.02, 0.98, "",
            fontsize=10, va="top", transform=axa.transAxes,
            bbox=dict(boxstyle="round", facecolor="white", alpha=0.92)
        )

        def pivot_xy(xi):
            # верх тележки: cart_y=-cart_h/2 -> верх=0
            cart_y = -cart_h/2
            pivot_y = cart_y + cart_h/2
            return xi, pivot_y

        def top_xy(xi, th):
            px, py = pivot_xy(xi)
            return px + L*np.sin(th), py + L*np.cos(th)

        step = max(1, int(0.02 / dt))
        frame_idx = np.arange(0, N, step)

        def init():
            rod.set_data([], [])
            bob.set_data([], [])
            top_traj.set_data([], [])
            pivot_traj.set_data([], [])
            text_box.set_text("")
            return rod, bob, cart, top_traj, pivot_traj, target_line, text_box

        def update(frame_number):
            k = frame_idx[frame_number]
            xi = x[k]
            th = theta[k]

            # тележка
            cart_x = xi - cart_w/2
            cart_y = -cart_h/2
            cart.set_xy((cart_x, cart_y))

            # точки маятника
            px, py = pivot_xy(xi)
            bx, by = top_xy(xi, th)

            rod.set_data([px, bx], [py, by])
            bob.set_data([bx], [by])

            # траектории (последние 250 "визуальных" точек)
            start = max(0, k - 250*step)
            xs = x[start:k+1]
            ths = theta[start:k+1]

            piv_x = xs
            piv_y = np.zeros_like(xs)  # верх тележки всегда y=0
            pivot_traj.set_data(piv_x, piv_y)

            top_x = piv_x + L*np.sin(ths)
            top_y = piv_y + L*np.cos(ths)
            top_traj.set_data(top_x, top_y)

            target_line.set_xdata([x_ref, x_ref])

            # статус
            angle_err_deg = abs(np.rad2deg(angle_wrap(th - theta_ref)))
            pos_err = abs(xi - x_ref)
            if angle_err_deg < 5.0 and pos_err < 0.5 and abs(theta_dot[k]) < 0.5:
                status = "СТАБИЛЬНО ✓"
            elif angle_err_deg < 15.0:
                status = "СТАБИЛИЗИРУЕТСЯ"
            else:
                status = "НЕСТАБИЛЬНО"

            # ТЕЛЕМЕТРИЯ: строчками, обозначения + подписи + единицы
            theta_err_deg_signed = np.rad2deg(angle_wrap(th - theta_ref))
            lines = [
                "СОСТОЯНИЕ СИСТЕМЫ",
                "-------------------------",
                f"t      : {t[k]:6.2f}  с        (время)",
                "",
                f"x      : {xi:+6.2f}  м        (позиция тележки)",
                f"x_err  : {xi-x_ref:+6.2f}  м        (ошибка позиции)",
                f"x_dot  : {state[k,1]:+6.2f}  м/с      (скорость тележки)",
                "",
                f"θ      : {np.rad2deg(th):+6.2f}  °        (угол маятника)",
                f"θ_err  : {theta_err_deg_signed:+6.2f}  °        (ошибка угла, со знаком)",
                f"θ_dot  : {theta_dot[k]:+6.2f}  рад/с    (угловая скорость)",
                "",
                f"F      : {F_arr[k]:+6.1f}  Н        (управляющая сила)",
                "",
                f"СТАТУС : {status}",
            ]

            if mode == 'CASCADE':
                lines += [
                    "",
                    "PID РЕГУЛЯТОР ПОЗИЦИИ",
                    "-------------------------",
                    f"P      : {pid_P_arr[k]:+7.4f}  рад      (пропорц.)",
                    f"I      : {pid_I_arr[k]:+7.4f}  рад      (интеграл)",
                    f"D      : {pid_D_arr[k]:+7.4f}  рад      (производн.)",
                    f"∫e dt  : {pid_int_arr[k]:+7.3f}          (инт. ошибка)",
                    "",
                    f"θ_des  : {np.rad2deg(theta_desired_arr[k]):+6.2f}  °        (заданный угол)"
                ]

            text_box.set_text("\n".join(lines))
            return rod, bob, cart, top_traj, pivot_traj, target_line, text_box

        anim = FuncAnimation(
            fig, update, init_func=init,
            frames=len(frame_idx),
            interval=1000 * dt * step,
            blit=True
        )

        plt.close(fig)
        display(HTML(anim.to_jshtml()))

    # ---------- СТАТИСТИКА ----------
    print(f"\n{'='*60}")
    print(f"СТАТИСТИКА ({mode}) | трек ±{track_length/2} м | цель {x_ref} м")
    print(f"{'='*60}")
    print(f"Макс |θ|: {np.max(np.abs(np.rad2deg(theta))):.1f}°")
    print(f"Макс |F|: {np.max(np.abs(F_arr)):.1f} Н")
    print(f"Макс |x_dot|: {np.max(np.abs(state[:,1])):.2f} м/с")
    print(f"Путь: {np.sum(np.abs(np.diff(x))):.1f} м")
    final_pos_error = abs(x[-1] - x_ref)
    final_angle_error = abs(np.rad2deg(angle_wrap(theta[-1] - theta_ref)))
    print(f"Финальная ошибка: x={final_pos_error:.3f} м, θ={final_angle_error:.2f}°")
    if mode != 'Off':
        IAE_angle = np.trapz(np.abs(theta), t)
        IAE_position = np.trapz(np.abs(x - x_ref), t)
        print(f"IAE(угол): {IAE_angle:.2f} рад·с | IAE(позиция): {IAE_position:.2f} м·с")


# ---------- ВИДЖЕТЫ ДЛЯ COLAB ----------
mode_widget = widgets.Dropdown(
    options=[('Off','Off'),
             ('PD','PD'),
             ('Dog (пастушья)','Dog'),
             ('LQR','LQR'),
             ('Каскадный (рекомендуется)','CASCADE')],
    value='CASCADE',
    description='Режим:'
)

x_ref_widget = widgets.FloatSlider(value=5.0, min=-10, max=10, step=0.5,
                                   description='x_ref (м):', continuous_update=False,
                                   style={'description_width': 'initial'})
track_length_widget = widgets.FloatSlider(value=20.0, min=10, max=50, step=5,
                                          description='Длина трека (м):', continuous_update=False,
                                          style={'description_width': 'initial'})
theta_ref_widget = widgets.FloatSlider(value=0.0, min=-30, max=30, step=1,
                                       description='θ_ref (°):', continuous_update=False)

x0_widget = widgets.FloatSlider(value=0.0, min=-5, max=5, step=0.5,
                                description='x0 (м):', continuous_update=False)
xdot0_widget = widgets.FloatSlider(value=0.0, min=-5, max=5, step=0.1,
                                   description='ẋ0 (м/с):', continuous_update=False)

theta0_widget = widgets.FloatSlider(value=15.0, min=-60, max=60, step=5,
                                    description='θ0 (°):', continuous_update=False,
                                    style={'description_width': 'initial'})
thetadot0_widget = widgets.FloatSlider(value=0.0, min=-10, max=10, step=0.1,
                                       description='θ̇0 (рад/с):', continuous_update=False)

Kp_theta_widget = widgets.FloatSlider(value=80.0, min=10, max=200, step=5,
                                      description='Kθ_p:', continuous_update=False)
Kd_theta_widget = widgets.FloatSlider(value=15.0, min=1, max=50, step=1,
                                      description='Kθ_d:', continuous_update=False)

Kp_x_widget = widgets.FloatSlider(value=1.5, min=0.1, max=5.0, step=0.1,
                                  description='Kx_p:', continuous_update=False)
Kd_x_widget = widgets.FloatSlider(value=3.0, min=0.1, max=10.0, step=0.1,
                                  description='Kx_d:', continuous_update=False)

Q_xx_widget = widgets.FloatSlider(value=0.5, min=0.1, max=5.0, step=0.1,
                                  description='Q_xx:', continuous_update=False)
Q_xd_widget = widgets.FloatSlider(value=0.05, min=0.01, max=0.5, step=0.01,
                                  description='Q_xd:', continuous_update=False)
Q_theta_widget = widgets.FloatSlider(value=300.0, min=50, max=1000, step=50,
                                     description='Q_θ:', continuous_update=False)
Q_thetad_widget = widgets.FloatSlider(value=20.0, min=5, max=100, step=5,
                                      description='Q_θd:', continuous_update=False)
R_widget = widgets.FloatSlider(value=0.1, min=0.01, max=1, step=0.01,
                               description='R:', continuous_update=False)

pos_Kp_widget = widgets.FloatSlider(value=0.5, min=0.1, max=2.0, step=0.1,
                                    description='Pos_Kp:', continuous_update=False)
pos_Ki_widget = widgets.FloatSlider(value=0.05, min=0.0, max=0.2, step=0.01,
                                    description='Pos_Ki:', continuous_update=False)
pos_Kd_widget = widgets.FloatSlider(value=1.0, min=0.0, max=5.0, step=0.1,
                                    description='Pos_Kd:', continuous_update=False)

F_max_widget = widgets.FloatSlider(value=100.0, min=20, max=200, step=10,
                                   description='F_max (Н):', continuous_update=False,
                                   style={'description_width': 'initial'})
T_widget = widgets.FloatSlider(value=20.0, min=5, max=60, step=5,
                               description='Время (с):', continuous_update=False)
dt_widget = widgets.FloatLogSlider(value=0.01, base=10, min=-3, max=-1,
                                   description='dt:', continuous_update=False)
show_anim_widget = widgets.Checkbox(value=True, description='Анимация')

basic_tab = widgets.VBox([
    widgets.HTML("<h4>Основные</h4>"),
    widgets.HBox([x_ref_widget, track_length_widget]),
    widgets.HBox([theta_ref_widget, F_max_widget]),
    widgets.HBox([x0_widget, theta0_widget]),
    widgets.HBox([xdot0_widget, thetadot0_widget]),
    widgets.HBox([T_widget, dt_widget]),
    show_anim_widget
])

pd_tab = widgets.VBox([
    widgets.HTML("<h4>PD / Dog</h4>"),
    widgets.HBox([Kp_theta_widget, Kd_theta_widget]),
    widgets.HBox([Kp_x_widget, Kd_x_widget]),
])

lqr_tab = widgets.VBox([
    widgets.HTML("<h4>LQR</h4>"),
    widgets.HBox([Q_xx_widget, Q_xd_widget]),
    widgets.HBox([Q_theta_widget, Q_thetad_widget]),
    R_widget
])

cascade_tab = widgets.VBox([
    widgets.HTML("<h4>CASCADE (PID позиции → θ_des)</h4>"),
    widgets.HBox([pos_Kp_widget, pos_Ki_widget]),
    pos_Kd_widget
])

accordion = Accordion(children=[basic_tab, pd_tab, lqr_tab, cascade_tab])
accordion.set_title(0, 'Основные')
accordion.set_title(1, 'PD/Dog')
accordion.set_title(2, 'LQR')
accordion.set_title(3, 'CASCADE (PID)')

controls = widgets.VBox([mode_widget, widgets.HTML("<hr>"), accordion])

out = widgets.interactive_output(
    simulate_and_plot_cart_pole,
    dict(
        mode=mode_widget,
        x_ref=x_ref_widget,
        theta_ref_deg=theta_ref_widget,
        x0=x0_widget,
        xdot0=xdot0_widget,
        theta0_deg=theta0_widget,
        thetadot0=thetadot0_widget,
        Kp_theta=Kp_theta_widget,
        Kd_theta=Kd_theta_widget,
        Kp_x=Kp_x_widget,
        Kd_x=Kd_x_widget,
        F_max=F_max_widget,
        Q_xx=Q_xx_widget,
        Q_xd=Q_xd_widget,
        Q_theta=Q_theta_widget,
        Q_thetad=Q_thetad_widget,
        R_val=R_widget,
        pos_Kp=pos_Kp_widget,
        pos_Ki=pos_Ki_widget,
        pos_Kd=pos_Kd_widget,
        T=T_widget,
        dt=dt_widget,
        show_animation=show_anim_widget,
        track_length=track_length_widget
    )
)

display(controls, out)

# -*- coding: utf-8 -*-
# Cart-Pole (тележка + перевёрнутый маятник)
# ✅ Нормальная геометрия (aspect='equal')
# ✅ Траектория верхней точки (груза) + траектория точки крепления
# ✅ CASCADE: PID не пересоздаётся каждый шаг
# ✅ Телеметрия: значения строчками с подписями и единицами
# ✅ Экспорт видео (MP4/GIF) + автоматическое скачивание в Google Colab

import os
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import HTML, display
import ipywidgets as widgets
from scipy.linalg import solve_continuous_are
from ipywidgets import Accordion

# ---------- ПАРАМЕТРЫ СИСТЕМЫ ----------
M = 1.0
m = 0.2
L = 1.0
g = 9.81
mu = 0.05

def cart_pole_dynamics(state, F):
    """
    state = [x, x_dot, theta, theta_dot]
    theta=0 -> маятник вертикально вверх (стабилизация вокруг 0)
    """
    x, x_dot, theta, theta_dot = state
    sin_th = np.sin(theta)
    cos_th = np.cos(theta)

    total_mass = M + m
    temp = (F + m * L * theta_dot**2 * sin_th - mu * x_dot) / total_mass

    theta_ddot = (g * sin_th - cos_th * temp) / (
        L * (4.0/3.0 - m * cos_th**2 / total_mass)
    )
    x_ddot = temp - m * L * theta_ddot * cos_th / total_mass

    return np.array([x_dot, x_ddot, theta_dot, theta_ddot])

def linearized_system_matrices():
    total_mass = M + m
    A = np.array([
        [0, 1, 0, 0],
        [0, -mu/total_mass, -m*g/total_mass, 0],
        [0, 0, 0, 1],
        [0, -mu/(L*total_mass), (M+m)*g/(L*total_mass), 0]
    ])
    B = np.array([
        [0],
        [1/total_mass],
        [0],
        [1/(L*total_mass)]
    ])
    return A, B

def compute_lqr_gain(Q_diag, R_val):
    A, B = linearized_system_matrices()
    Q = np.diag(Q_diag)
    R = np.array([[R_val]])
    try:
        P = solve_continuous_are(A, B, Q, R)
        K = np.linalg.inv(R) @ B.T @ P
        return K.flatten(), True
    except Exception:
        print("LQR решение не найдено, используем эвристические коэффициенты")
        return np.array([-2.0, -3.0, -50.0, -10.0]), False

def angle_wrap(theta):
    return (theta + np.pi) % (2*np.pi) - np.pi

# ---------- КОНТРОЛЛЕРЫ ----------
class PIDController:
    """PID: возвращает u и разложение на P/I/D"""
    def __init__(self, Kp, Ki, Kd, max_output, dt, integral_limit=None):
        self.Kp = Kp
        self.Ki = Ki
        self.Kd = Kd
        self.max_output = max_output
        self.dt = dt
        self.integral = 0.0
        self.prev_error = 0.0
        self.integral_limit = integral_limit

    def reset(self):
        self.integral = 0.0
        self.prev_error = 0.0

    def update(self, error):
        self.integral += error * self.dt
        if self.integral_limit is not None:
            self.integral = np.clip(self.integral, -self.integral_limit, self.integral_limit)

        derivative = (error - self.prev_error) / self.dt if self.dt > 0 else 0.0
        self.prev_error = error

        P = self.Kp * error
        I = self.Ki * self.integral
        D = self.Kd * derivative
        u = P + I + D
        u_sat = float(np.clip(u, -self.max_output, self.max_output))

        # простой anti-windup
        if u != u_sat and self.Ki != 0:
            self.integral *= 0.98

        return u_sat, P, I, D, self.integral

def controller_PD(x, x_dot, theta, theta_dot,
                  x_ref, theta_ref,
                  Kp_theta, Kd_theta, Kp_x, Kd_x, F_max):
    e_theta = angle_wrap(theta_ref - theta)
    e_x = x_ref - x
    F = (Kp_theta * e_theta +
         Kd_theta * (0.0 - theta_dot) +
         Kp_x * e_x +
         Kd_x * (0.0 - x_dot))
    return float(np.clip(F, -F_max, F_max))

def controller_DOG(x, x_dot, theta, theta_dot,
                   x_ref, theta_ref,
                   Kp_theta, Kd_theta, Kp_x, Kd_x, F_max):
    e_theta = angle_wrap(theta_ref - theta)
    e_x = x_ref - x
    F = (Kp_theta * np.tanh(2.0 * e_theta) +
         Kd_theta * np.tanh(-theta_dot/2.0) +
         Kp_x * np.tanh(e_x/5.0) +
         Kd_x * np.tanh(-x_dot/2.0))
    return float(np.clip(F, -F_max, F_max))

def controller_LQR(x, x_dot, theta, theta_dot,
                   x_ref, theta_ref, K, F_max):
    theta_error = angle_wrap(theta_ref - theta)
    x_error = x_ref - x
    state_error = np.array([x_error, -x_dot, theta_error, -theta_dot])
    F = -np.dot(K, state_error)
    return float(np.clip(F, -F_max, F_max))

# ---------- СИМУЛЯЦИЯ + ВИЗУАЛИЗАЦИЯ ----------
def simulate_and_plot_cart_pole(
    mode='CASCADE',
    x_ref=5.0,
    theta_ref_deg=0.0,
    x0=0.0,
    xdot0=0.0,
    theta0_deg=10.0,
    thetadot0=0.0,
    Kp_theta=80.0,
    Kd_theta=15.0,
    Kp_x=1.5,
    Kd_x=3.0,
    F_max=100.0,
    # LQR
    Q_xx=0.5,
    Q_xd=0.05,
    Q_theta=300.0,
    Q_thetad=20.0,
    R_val=0.1,
    # PID позиции
    pos_Kp=0.5,
    pos_Ki=0.05,
    pos_Kd=1.0,
    T=20.0,
    dt=0.01,
    show_animation=True,
    track_length=20.0,
    # экспорт
    save_video=False,
    video_format='mp4',      # 'mp4' или 'gif'
    video_filename='cartpole',
    video_fps=30
):
    plt.close('all')

    theta_ref = np.deg2rad(theta_ref_deg)
    theta0 = np.deg2rad(theta0_deg)

    N = int(T / dt)
    t = np.linspace(0, T, N)

    state = np.zeros((N, 4))
    state[0] = [x0, xdot0, theta0, thetadot0]
    F_arr = np.zeros(N)

    theta_desired_arr = np.zeros(N)
    pid_P_arr = np.zeros(N)
    pid_I_arr = np.zeros(N)
    pid_D_arr = np.zeros(N)
    pid_u_arr = np.zeros(N)
    pid_int_arr = np.zeros(N)

    # LQR
    K_lqr = None
    if mode in ['LQR', 'CASCADE']:
        Q_diag = [Q_xx, Q_xd, Q_theta, Q_thetad]
        K_lqr, success = compute_lqr_gain(Q_diag, R_val)
        if success:
            print(f"LQR K = [{K_lqr[0]:.3f}, {K_lqr[1]:.3f}, {K_lqr[2]:.3f}, {K_lqr[3]:.3f}]")
        else:
            print(f"Эвристический K = [{K_lqr[0]:.3f}, {K_lqr[1]:.3f}, {K_lqr[2]:.3f}, {K_lqr[3]:.3f}]")

    # PID создаём один раз
    pos_pid = None
    if mode == 'CASCADE':
        pos_pid = PIDController(
            pos_Kp, pos_Ki, pos_Kd,
            max_output=np.deg2rad(30),
            dt=dt,
            integral_limit=50.0
        )

    for k in range(N - 1):
        x, x_dot, theta, theta_dot = state[k]

        if mode == 'Off':
            F = 0.0

        elif mode == 'PD':
            F = controller_PD(x, x_dot, theta, theta_dot, x_ref, theta_ref,
                              Kp_theta, Kd_theta, Kp_x, Kd_x, F_max)

        elif mode == 'Dog':
            F = controller_DOG(x, x_dot, theta, theta_dot, x_ref, theta_ref,
                               Kp_theta, Kd_theta, Kp_x, Kd_x, F_max)

        elif mode == 'LQR':
            F = controller_LQR(x, x_dot, theta, theta_dot, x_ref, theta_ref, K_lqr, F_max)

        elif mode == 'CASCADE':
            e_x = x_ref - x
            u_pid, P, I, D, integ = pos_pid.update(e_x)
            theta_desired = float(np.clip(u_pid, np.deg2rad(-30), np.deg2rad(30)))

            theta_desired_arr[k] = theta_desired
            pid_u_arr[k] = u_pid
            pid_P_arr[k] = P
            pid_I_arr[k] = I
            pid_D_arr[k] = D
            pid_int_arr[k] = integ

            if K_lqr is not None:
                F = controller_LQR(x, x_dot, theta, theta_dot, x_ref, theta_desired, K_lqr, F_max)
            else:
                F = controller_PD(x, x_dot, theta, theta_dot, x_ref, theta_desired,
                                  Kp_theta, Kd_theta, 0, 0, F_max)
        else:
            F = 0.0

        F_arr[k] = F
        state[k+1] = state[k] + dt * cart_pole_dynamics(state[k], F)

    x = state[:, 0]
    theta = state[:, 2]
    theta_dot = state[:, 3]

    # ---------- ГРАФИКИ ----------
    if mode == 'CASCADE':
        fig1, ax = plt.subplots(5, 1, figsize=(11, 12), sharex=True)
    else:
        fig1, ax = plt.subplots(4, 1, figsize=(11, 10), sharex=True)

    ax[0].plot(t, x, label='x(t)', linewidth=2)
    ax[0].axhline(x_ref, linestyle='--', color='k', label='x_ref', linewidth=2)
    ax[0].axhline(track_length/2, linestyle=':', color='gray', alpha=0.5)
    ax[0].axhline(-track_length/2, linestyle=':', color='gray', alpha=0.5)
    ax[0].fill_between(t, -track_length/2, track_length/2, alpha=0.08)
    ax[0].set_ylabel("x, м")
    ax[0].grid(True, alpha=0.3)
    ax[0].legend(loc='upper right')
    ax[0].set_ylim(-track_length/2-1, track_length/2+1)

    ax[1].plot(t, np.rad2deg(theta), label='θ(t)', linewidth=2)
    ax[1].axhline(theta_ref_deg, linestyle='--', color='k', label='θ_ref', linewidth=2)
    if mode == 'CASCADE':
        ax[1].plot(t, np.rad2deg(theta_desired_arr), '--', label='θ_desired', alpha=0.8)
    ax[1].axhline(30, linestyle=':', alpha=0.5)
    ax[1].axhline(-30, linestyle=':', alpha=0.5)
    ax[1].set_ylabel("θ, °")
    ax[1].grid(True, alpha=0.3)
    ax[1].legend(loc='upper right')
    ax[1].set_ylim(-45, 45)

    ax[2].plot(t, F_arr, label='F(t)', linewidth=2)
    ax[2].axhline(F_max, linestyle='--', linewidth=1, alpha=0.7, label='±F_max')
    ax[2].axhline(-F_max, linestyle='--', linewidth=1, alpha=0.7)
    ax[2].fill_between(t, -F_max, F_max, alpha=0.08)
    ax[2].set_ylabel("F, Н")
    ax[2].grid(True, alpha=0.3)
    ax[2].legend(loc='upper right')

    ax[3].plot(t, state[:, 1], label='x_dot', linewidth=1.5)
    ax[3].plot(t, state[:, 3], label='theta_dot', linewidth=1.5)
    ax[3].set_ylabel("скорости")
    ax[3].grid(True, alpha=0.3)
    ax[3].legend(loc='upper right')
    ax[-1].set_xlabel("t, c")

    if mode == 'CASCADE':
        ax[4].plot(t, pid_P_arr, label='PID P', linewidth=1.5)
        ax[4].plot(t, pid_I_arr, label='PID I', linewidth=1.5)
        ax[4].plot(t, pid_D_arr, label='PID D', linewidth=1.5)
        ax[4].plot(t, pid_u_arr, label='PID u (до clip)', linewidth=1.0, alpha=0.7)
        ax[4].set_ylabel("PID (рад)")
        ax[4].grid(True, alpha=0.3)
        ax[4].legend(loc='upper right')

    fig1.suptitle(f"Cart-Pole | mode={mode} | x_ref={x_ref} м | track={track_length} м")
    plt.tight_layout()
    plt.show()

    # ---------- АНИМАЦИЯ + СОХРАНЕНИЕ ----------
    if show_animation:
        fig, axa = plt.subplots(figsize=(12, 6))

        x_min_view = min(np.min(x) - 3.0, -track_length/2 - 2.0)
        x_max_view = max(np.max(x) + 3.0,  track_length/2 + 2.0)

        axa.set_xlim(x_min_view, x_max_view)
        axa.set_ylim(-1.5, 3.0)
        axa.set_xlabel("x, м")
        axa.set_ylabel("y, м")
        axa.set_aspect('equal', adjustable='box')

        axa.axhline(0, color="black", linewidth=2)
        axa.axvline(-track_length/2, color='black', linewidth=3)
        axa.axvline(track_length/2, color='black', linewidth=3)
        axa.grid(True, linestyle=":", linewidth=0.5, alpha=0.5)
        axa.set_title(f"Перевёрнутый маятник | {mode} | трек ±{track_length/2} м")

        cart_w, cart_h = 1.5, 0.8
        cart = plt.Rectangle((0, 0), cart_w, cart_h, fc="blue", ec="blue", linewidth=2, alpha=0.9)
        axa.add_patch(cart)

        rod, = axa.plot([], [], lw=4, color='black', alpha=0.9)
        bob, = axa.plot([], [], 'o', color='orange', markersize=10)

        top_traj, = axa.plot([], [], '-', color='orange', linewidth=1.5, alpha=0.55)
        pivot_traj, = axa.plot([], [], '-', color='black', linewidth=1.0, alpha=0.25)

        target_line = axa.axvline(x_ref, color='green', linestyle='--', linewidth=2, alpha=0.8)

        text_box = axa.text(
            0.02, 0.98, "",
            fontsize=10, va="top", transform=axa.transAxes,
            bbox=dict(boxstyle="round", facecolor="white", alpha=0.92)
        )

        def pivot_xy(xi):
            cart_y = -cart_h/2
            pivot_y = cart_y + cart_h/2  # верх тележки -> 0
            return xi, pivot_y

        def top_xy(xi, th):
            px, py = pivot_xy(xi)
            return px + L*np.sin(th), py + L*np.cos(th)

        step = max(1, int(0.02 / dt))
        frame_idx = np.arange(0, N, step)

        def init():
            rod.set_data([], [])
            bob.set_data([], [])
            top_traj.set_data([], [])
            pivot_traj.set_data([], [])
            text_box.set_text("")
            return rod, bob, cart, top_traj, pivot_traj, target_line, text_box

        def update(frame_number):
            k = frame_idx[frame_number]
            xi = x[k]
            th = theta[k]

            cart_x = xi - cart_w/2
            cart_y = -cart_h/2
            cart.set_xy((cart_x, cart_y))

            px, py = pivot_xy(xi)
            bx, by = top_xy(xi, th)

            rod.set_data([px, bx], [py, by])
            bob.set_data([bx], [by])

            start = max(0, k - 250*step)
            xs = x[start:k+1]
            ths = theta[start:k+1]

            piv_x = xs
            piv_y = np.zeros_like(xs)  # верх тележки y=0
            pivot_traj.set_data(piv_x, piv_y)

            top_x = piv_x + L*np.sin(ths)
            top_y = piv_y + L*np.cos(ths)
            top_traj.set_data(top_x, top_y)

            target_line.set_xdata([x_ref, x_ref])

            angle_err_deg_abs = abs(np.rad2deg(angle_wrap(th - theta_ref)))
            pos_err_abs = abs(xi - x_ref)
            if angle_err_deg_abs < 5.0 and pos_err_abs < 0.5 and abs(theta_dot[k]) < 0.5:
                status = "СТАБИЛЬНО ✓"
            elif angle_err_deg_abs < 15.0:
                status = "СТАБИЛИЗИРУЕТСЯ"
            else:
                status = "НЕСТАБИЛЬНО"

            theta_err_deg_signed = np.rad2deg(angle_wrap(th - theta_ref))

            lines = [
                "СОСТОЯНИЕ СИСТЕМЫ",
                "-------------------------",
                f"t      : {t[k]:6.2f}  с        (время)",
                "",
                f"x      : {xi:+6.2f}  м        (позиция тележки)",
                f"x_err  : {xi-x_ref:+6.2f}  м        (ошибка позиции)",
                f"x_dot  : {state[k,1]:+6.2f}  м/с      (скорость тележки)",
                "",
                f"θ      : {np.rad2deg(th):+6.2f}  °        (угол маятника)",
                f"θ_err  : {theta_err_deg_signed:+6.2f}  °        (ошибка угла, со знаком)",
                f"θ_dot  : {theta_dot[k]:+6.2f}  рад/с    (угловая скорость)",
                "",
                f"F      : {F_arr[k]:+6.1f}  Н        (управляющая сила)",
                "",
                f"СТАТУС : {status}",
            ]

            if mode == 'CASCADE':
                lines += [
                    "",
                    "PID РЕГУЛЯТОР ПОЗИЦИИ",
                    "-------------------------",
                    f"P      : {pid_P_arr[k]:+7.4f}  рад      (пропорц.)",
                    f"I      : {pid_I_arr[k]:+7.4f}  рад      (интеграл)",
                    f"D      : {pid_D_arr[k]:+7.4f}  рад      (производн.)",
                    f"∫e dt  : {pid_int_arr[k]:+7.3f}          (инт. ошибка)",
                    "",
                    f"θ_des  : {np.rad2deg(theta_desired_arr[k]):+6.2f}  °        (заданный угол)"
                ]

            text_box.set_text("\n".join(lines))
            return rod, bob, cart, top_traj, pivot_traj, target_line, text_box

        anim = FuncAnimation(
            fig, update, init_func=init,
            frames=len(frame_idx),
            interval=1000 * dt * step,
            blit=True
        )

        # показать в ноутбуке
        plt.close(fig)
        display(HTML(anim.to_jshtml()))

        # ---- сохранить и скачать ----
        if save_video:
            out_name = f"{video_filename}.{video_format}".replace("..", ".")
            out_path = os.path.abspath(out_name)

            print(f"\nСохраняю видео: {out_path}")

            if video_format.lower() == 'mp4':
                # mp4 через ffmpeg
                import subprocess
                try:
                    subprocess.run(["bash", "-lc", "ffmpeg -version"], check=True, capture_output=True)
                except Exception:
                    subprocess.run(["bash", "-lc", "apt-get -y update && apt-get -y install ffmpeg"], check=True)

                from matplotlib.animation import FFMpegWriter
                writer = FFMpegWriter(fps=int(video_fps), bitrate=1800)
                anim.save(out_path, writer=writer)

            elif video_format.lower() == 'gif':
                from matplotlib.animation import PillowWriter
                writer = PillowWriter(fps=int(video_fps))
                anim.save(out_path, writer=writer)
            else:
                raise ValueError("video_format должен быть 'mp4' или 'gif'")

            print("Готово. Начинаю скачивание...")
            from google.colab import files
            files.download(out_path)

    # ---------- СТАТИСТИКА ----------
    print(f"\n{'='*60}")
    print(f"СТАТИСТИКА ({mode}) | трек ±{track_length/2} м | цель {x_ref} м")
    print(f"{'='*60}")
    print(f"Макс |θ|: {np.max(np.abs(np.rad2deg(theta))):.1f}°")
    print(f"Макс |F|: {np.max(np.abs(F_arr)):.1f} Н")
    print(f"Макс |x_dot|: {np.max(np.abs(state[:,1])):.2f} м/с")
    print(f"Путь: {np.sum(np.abs(np.diff(x))):.1f} м")
    final_pos_error = abs(x[-1] - x_ref)
    final_angle_error = abs(np.rad2deg(angle_wrap(theta[-1] - theta_ref)))
    print(f"Финальная ошибка: x={final_pos_error:.3f} м, θ={final_angle_error:.2f}°")
    if mode != 'Off':
        IAE_angle = np.trapz(np.abs(theta), t)
        IAE_position = np.trapz(np.abs(x - x_ref), t)
        print(f"IAE(угол): {IAE_angle:.2f} рад·с | IAE(позиция): {IAE_position:.2f} м·с")


# ---------- ВИДЖЕТЫ ДЛЯ COLAB ----------
mode_widget = widgets.Dropdown(
    options=[('Off','Off'),
             ('PD','PD'),
             ('Dog (пастушья)','Dog'),
             ('LQR','LQR'),
             ('Каскадный (рекомендуется)','CASCADE')],
    value='CASCADE',
    description='Режим:'
)

x_ref_widget = widgets.FloatSlider(value=5.0, min=-10, max=10, step=0.5,
                                   description='x_ref (м):', continuous_update=False,
                                   style={'description_width': 'initial'})
track_length_widget = widgets.FloatSlider(value=20.0, min=10, max=50, step=5,
                                          description='Длина трека (м):', continuous_update=False,
                                          style={'description_width': 'initial'})
theta_ref_widget = widgets.FloatSlider(value=0.0, min=-30, max=30, step=1,
                                       description='θ_ref (°):', continuous_update=False)

x0_widget = widgets.FloatSlider(value=0.0, min=-5, max=5, step=0.5,
                                description='x0 (м):', continuous_update=False)
xdot0_widget = widgets.FloatSlider(value=0.0, min=-5, max=5, step=0.1,
                                   description='ẋ0 (м/с):', continuous_update=False)

theta0_widget = widgets.FloatSlider(value=15.0, min=-60, max=60, step=5,
                                    description='θ0 (°):', continuous_update=False,
                                    style={'description_width': 'initial'})
thetadot0_widget = widgets.FloatSlider(value=0.0, min=-10, max=10, step=0.1,
                                       description='θ̇0 (рад/с):', continuous_update=False)

Kp_theta_widget = widgets.FloatSlider(value=80.0, min=10, max=200, step=5,
                                      description='Kθ_p:', continuous_update=False)
Kd_theta_widget = widgets.FloatSlider(value=15.0, min=1, max=50, step=1,
                                      description='Kθ_d:', continuous_update=False)

Kp_x_widget = widgets.FloatSlider(value=1.5, min=0.1, max=5.0, step=0.1,
                                  description='Kx_p:', continuous_update=False)
Kd_x_widget = widgets.FloatSlider(value=3.0, min=0.1, max=10.0, step=0.1,
                                  description='Kx_d:', continuous_update=False)

Q_xx_widget = widgets.FloatSlider(value=0.5, min=0.1, max=5.0, step=0.1,
                                  description='Q_xx:', continuous_update=False)
Q_xd_widget = widgets.FloatSlider(value=0.05, min=0.01, max=0.5, step=0.01,
                                  description='Q_xd:', continuous_update=False)
Q_theta_widget = widgets.FloatSlider(value=300.0, min=50, max=1000, step=50,
                                     description='Q_θ:', continuous_update=False)
Q_thetad_widget = widgets.FloatSlider(value=20.0, min=5, max=100, step=5,
                                      description='Q_θd:', continuous_update=False)
R_widget = widgets.FloatSlider(value=0.1, min=0.01, max=1, step=0.01,
                               description='R:', continuous_update=False)

pos_Kp_widget = widgets.FloatSlider(value=0.5, min=0.1, max=2.0, step=0.1,
                                    description='Pos_Kp:', continuous_update=False)
pos_Ki_widget = widgets.FloatSlider(value=0.05, min=0.0, max=0.2, step=0.01,
                                    description='Pos_Ki:', continuous_update=False)
pos_Kd_widget = widgets.FloatSlider(value=1.0, min=0.0, max=5.0, step=0.1,
                                    description='Pos_Kd:', continuous_update=False)

F_max_widget = widgets.FloatSlider(value=100.0, min=20, max=200, step=10,
                                   description='F_max (Н):', continuous_update=False,
                                   style={'description_width': 'initial'})
T_widget = widgets.FloatSlider(value=20.0, min=5, max=60, step=5,
                               description='Время (с):', continuous_update=False)
dt_widget = widgets.FloatLogSlider(value=0.01, base=10, min=-3, max=-1,
                                   description='dt:', continuous_update=False)
show_anim_widget = widgets.Checkbox(value=True, description='Анимация')

# --- экспорт видео ---
save_video_widget = widgets.Checkbox(value=False, description='Сохранить видео и скачать')
video_format_widget = widgets.Dropdown(options=['mp4','gif'], value='mp4', description='Формат:')
video_fps_widget = widgets.IntSlider(value=30, min=10, max=60, step=5, description='FPS:')
video_name_widget = widgets.Text(value='cartpole', description='Имя файла:')

basic_tab = widgets.VBox([
    widgets.HTML("<h4>Основные</h4>"),
    widgets.HBox([x_ref_widget, track_length_widget]),
    widgets.HBox([theta_ref_widget, F_max_widget]),
    widgets.HBox([x0_widget, theta0_widget]),
    widgets.HBox([xdot0_widget, thetadot0_widget]),
    widgets.HBox([T_widget, dt_widget]),
    show_anim_widget,
    widgets.HTML("<hr><b>Экспорт видео</b>"),
    widgets.HBox([save_video_widget, video_format_widget]),
    widgets.HBox([video_fps_widget, video_name_widget]),
])

pd_tab = widgets.VBox([
    widgets.HTML("<h4>PD / Dog</h4>"),
    widgets.HBox([Kp_theta_widget, Kd_theta_widget]),
    widgets.HBox([Kp_x_widget, Kd_x_widget]),
])

lqr_tab = widgets.VBox([
    widgets.HTML("<h4>LQR</h4>"),
    widgets.HBox([Q_xx_widget, Q_xd_widget]),
    widgets.HBox([Q_theta_widget, Q_thetad_widget]),
    R_widget
])

cascade_tab = widgets.VBox([
    widgets.HTML("<h4>CASCADE (PID позиции → θ_des)</h4>"),
    widgets.HBox([pos_Kp_widget, pos_Ki_widget]),
    pos_Kd_widget
])

accordion = Accordion(children=[basic_tab, pd_tab, lqr_tab, cascade_tab])
accordion.set_title(0, 'Основные')
accordion.set_title(1, 'PD/Dog')
accordion.set_title(2, 'LQR')
accordion.set_title(3, 'CASCADE (PID)')

controls = widgets.VBox([mode_widget, widgets.HTML("<hr>"), accordion])

out = widgets.interactive_output(
    simulate_and_plot_cart_pole,
    dict(
        mode=mode_widget,
        x_ref=x_ref_widget,
        theta_ref_deg=theta_ref_widget,
        x0=x0_widget,
        xdot0=xdot0_widget,
        theta0_deg=theta0_widget,
        thetadot0=thetadot0_widget,
        Kp_theta=Kp_theta_widget,
        Kd_theta=Kd_theta_widget,
        Kp_x=Kp_x_widget,
        Kd_x=Kd_x_widget,
        F_max=F_max_widget,
        Q_xx=Q_xx_widget,
        Q_xd=Q_xd_widget,
        Q_theta=Q_theta_widget,
        Q_thetad=Q_thetad_widget,
        R_val=R_widget,
        pos_Kp=pos_Kp_widget,
        pos_Ki=pos_Ki_widget,
        pos_Kd=pos_Kd_widget,
        T=T_widget,
        dt=dt_widget,
        show_animation=show_anim_widget,
        track_length=track_length_widget,
        save_video=save_video_widget,
        video_format=video_format_widget,
        video_filename=video_name_widget,
        video_fps=video_fps_widget
    )
)

display(controls, out)

# Commented out IPython magic to ensure Python compatibility.
# ================== 3D АНИМАЦИЯ ПЕРЕВЁРНУТОГО МАЯТНИКА ==================
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import HTML
from mpl_toolkits.mplot3d.art3d import Poly3DCollection

# %matplotlib inline

# --- параметры системы ---
M = 1.0     # масса тележки, кг
m = 0.1     # масса маятника, кг
L = 0.5     # длина стержня, м
g = 9.81

# --- динамика ---
def dynamics(state, F):
    """
    state = [x, x_dot, theta, theta_dot]
    F — сила на тележку
    """
    x, x_dot, th, th_dot = state
    sin_t, cos_t = np.sin(th), np.cos(th)
    den = M + m * sin_t**2

    x_dd = (F + m * sin_t * (L * th_dot**2 + g * cos_t)) / den
    th_dd = (-F * cos_t
             - m * L * th_dot**2 * cos_t * sin_t
             - (M + m) * g * sin_t) / (L * den)

    return np.array([x_dot, x_dd, th, th_dd])

# --- PD-контроллер ---
def PD(x, x_dot, th, th_dot):
    th_err = -th
    th_d_err = -th_dot
    x_err = -x
    x_d_err = -x_dot

    F = 60 * th_err + 10 * th_d_err + 2 * x_err + 4 * x_d_err
    return np.clip(F, -50, 50)

# --- параметры моделирования ---
dt = 0.01
T = 10.0
N = int(T / dt)
t = np.linspace(0, T, N)

state = np.zeros((N, 4))
state[0] = [0.0, 0.0, np.deg2rad(8), 0.0]    # начальное состояние

# --- параметры "землетрясения" ---
quake_start = 2.0
quake_end   = 3.5
quake_amp   = 40.0
quake_freq  = 5.0

F_hist = np.zeros(N)

# --- численное интегрирование ---
for i in range(N - 1):
    x, x_dot, th, th_dot = state[i]

    # управление
    F_ctrl = PD(x, x_dot, th, th_dot)

    # землетрясение
    if quake_start < t[i] < quake_end:
        tau = t[i] - quake_start
        F_quake = quake_amp * np.sin(2 * np.pi * quake_freq * tau)
    else:
        F_quake = 0.0

    F = F_ctrl + F_quake
    F_hist[i] = F

    state[i + 1] = state[i] + dt * dynamics(state[i], F)

x = state[:, 0]
th = state[:, 2]

# координаты маятника в 3D (движение в плоскости X–Z, по Y = 0)
pivot_x = x
pivot_y = np.zeros_like(x)
pivot_z = np.zeros_like(x)

bob_x = pivot_x + L * np.sin(th)
bob_y = np.zeros_like(x)
bob_z = pivot_z + L * np.cos(th)

# ================== 3D АНИМАЦИЯ ==================

fig = plt.figure(figsize=(9, 6))
ax = fig.add_subplot(111, projection='3d')

# границы сцены
x_min, x_max = -3, 3
z_min, z_max = -0.5, 2.0
y_min, y_max = -1.0, 1.0

ax.set_xlim(x_min, x_max)
ax.set_ylim(y_min, y_max)
ax.set_zlim(z_min, z_max)

ax.set_xlabel("X (м)")
ax.set_ylabel("Y (м)")
ax.set_zlabel("Z (м)")
ax.set_title("3D: перевёрнутый маятник на тележке (землетрясение)")

# "земля"
ax.plot([x_min, x_max], [0, 0], [0, 0], color='black')

# --- тележка как синий прямоугольный параллелепипед ---
cart_w = 0.6   # ширина по X
cart_d = 0.5   # глубина по Y
cart_h = 0.25  # высота по Z

def make_cart_vertices(cx, cy=0.0, base_z=0.0):
    """Возвращает 8 вершин параллелепипеда тележки."""
    x0 = cx - cart_w / 2
    x1 = cx + cart_w / 2
    y0 = cy - cart_d / 2
    y1 = cy + cart_d / 2
    z0 = base_z
    z1 = base_z + cart_h

    # 8 вершин
    v = np.array([
        [x0, y0, z0],
        [x1, y0, z0],
        [x1, y1, z0],
        [x0, y1, z0],
        [x0, y0, z1],
        [x1, y0, z1],
        [x1, y1, z1],
        [x0, y1, z1],
    ])
    # 6 граней (каждая — список индексов вершин)
    faces = [
        [v[0], v[1], v[2], v[3]],  # низ
        [v[4], v[5], v[6], v[7]],  # верх
        [v[0], v[1], v[5], v[4]],  # бок
        [v[1], v[2], v[6], v[5]],
        [v[2], v[3], v[7], v[6]],
        [v[3], v[0], v[4], v[7]],
    ]
    return faces

# создаём каркас тележки для первого кадра
initial_faces = make_cart_vertices(x[0])
cart_poly = Poly3DCollection(
    initial_faces,
    facecolors='blue',
    edgecolors='blue',
    linewidths=1.0,
    alpha=0.9
)
ax.add_collection3d(cart_poly)

# маятник
rod_line, = ax.plot([], [], [], lw=3, color='black')
bob_point, = ax.plot([], [], [], 'o', color='orange', markersize=10)

# текст с параметрами
info_text = ax.text2D(
    0.02, 0.95, "",
    transform=ax.transAxes,
    fontsize=10,
    bbox=dict(boxstyle="round", facecolor="white", alpha=0.8)
)

def set_equal_aspect_3d(ax):
    """Равные масштабы по осям для 3D."""
    xr = ax.get_xlim3d()
    yr = ax.get_ylim3d()
    zr = ax.get_zlim3d()
    x_mid = 0.5 * (xr[0] + xr[1])
    y_mid = 0.5 * (yr[0] + yr[1])
    z_mid = 0.5 * (zr[0] + zr[1])
    max_range = max(
        xr[1] - xr[0],
        yr[1] - yr[0],
        zr[1] - zr[0]
    )
    r = 0.5 * max_range
    ax.set_xlim3d([x_mid - r, x_mid + r])
    ax.set_ylim3d([y_mid - r, y_mid + r])
    ax.set_zlim3d([z_mid - r, z_mid + r])

set_equal_aspect_3d(ax)

def init():
    rod_line.set_data([], [])
    rod_line.set_3d_properties([])
    bob_point.set_data([], [])
    bob_point.set_3d_properties([])
    info_text.set_text("")
    return rod_line, bob_point, cart_poly, info_text

step = 3  # прореживание кадров
frames = range(0, N, step)

def update(i):
    cx = x[i]
    # обновляем тележку
    faces = make_cart_vertices(cx)
    cart_poly.set_verts(faces)

    # координаты маятника
    px, py, pz = pivot_x[i], pivot_y[i], pivot_z[i] + cart_h   # ось сверху тележки
    bx, by, bz = bob_x[i], bob_y[i], bob_z[i] + cart_h

    rod_line.set_data([px, bx], [py, by])
    rod_line.set_3d_properties([pz, bz])

    bob_point.set_data([bx], [by])
    bob_point.set_3d_properties([bz])

    # статус
    th_deg = np.rad2deg(th[i])
    th_dot = state[i, 3]
    status = "СТАБИЛЬНО" if abs(th_deg) < 15 and abs(th_dot) < 1.0 else "НЕСТАБИЛЬНО"

    info_text.set_text(
        f"t = {t[i]:.2f} c\n"
        f"θ = {th_deg:+.1f}°\n"
        f"x = {x[i]:+.2f} м\n"
        f"Статус: {status}"
    )

    return rod_line, bob_point, cart_poly, info_text

anim = FuncAnimation(
    fig, update, frames=frames,
    init_func=init, interval=20, blit=False
)

plt.close(fig)
HTML(anim.to_jshtml())

!pip install fastapi uvicorn nest_asyncio

def make_anim_3d(path="/tmp/anim_3d.html"):
    t, state = simulate()
    x = state[:, 0]
    th = state[:, 2]

    pivot_x = x
    pivot_y = np.zeros_like(x)
    pivot_z = np.zeros_like(x)

    bob_x = pivot_x + L * np.sin(th)
    bob_y = np.zeros_like(x)
    bob_z = pivot_z + L * np.cos(th)

    fig = plt.figure(figsize=(7, 5))
    ax = fig.add_subplot(111, projection="3d")

    x_min, x_max = -3, 3
    y_min, y_max = -1, 1
    z_min, z_max = -0.5, 2.0

    ax.set_xlim(x_min, x_max)
    ax.set_ylim(y_min, y_max)
    ax.set_zlim(z_min, z_max)

    ax.set_xlabel("X (м)")
    ax.set_ylabel("Y (м)")
    ax.set_zlabel("Z (м)")
    ax.set_title("3D: маятник на тележке (с землетрясением)")

    ax.plot([x_min, x_max], [0, 0], [0, 0], color="black")

    # синяя тележка
    cart_w, cart_d, cart_h = 0.6, 0.5, 0.25

    # ⬇⬇⬇ ВАЖНО: исправлено x[0]() → x[0]
    faces0 = make_cart_vertices(x[0], 0.0, 0.0, cart_w, cart_d, cart_h)

    cart_poly = Poly3DCollection(
        faces0,
        facecolors="blue",
        edgecolors="blue",
        alpha=0.9
    )
    ax.add_collection3d(cart_poly)

    (rod,) = ax.plot([], [], [], lw=3, color="black")
    (bob,) = ax.plot([], [], [], "o", color="orange", markersize=8)

    set_equal_aspect_3d(ax)

    def init():
        rod.set_data([], [])
        rod.set_3d_properties([])
        bob.set_data([], [])
        bob.set_3d_properties([])
        return rod, bob, cart_poly

    def update(i):
        faces = make_cart_vertices(x[i], 0.0, 0.0, cart_w, cart_d, cart_h)
        cart_poly.set_verts(faces)

        px, py, pz = pivot_x[i], pivot_y[i], pivot_z[i] + cart_h
        bx, by, bz = bob_x[i], bob_y

# ================== ОДНА ЯЧЕЙКА ДЛЯ COLAB ==================
# УСТАНОВКА БИБЛИОТЕК
!pip install fastapi uvicorn nest_asyncio > /dev/null

import numpy as np
import matplotlib
matplotlib.use("Agg")  # рисуем в памяти (для анимаций через HTML)
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from mpl_toolkits.mplot3d.art3d import Poly3DCollection

from fastapi import FastAPI
from fastapi.responses import FileResponse, PlainTextResponse
import nest_asyncio
import uvicorn
import threading
import os
import requests
from IPython.display import HTML, display

# ================== ПАРАМЕТРЫ СИСТЕМЫ ==================
M = 1.0   # масса тележки
m = 0.1   # масса маятника
L = 0.5   # длина стержня
g = 9.81  # гравитация

# ---------- ДИНАМИКА ----------
def dynamics(state, F):
    """
    state = [x, x_dot, theta, theta_dot]
    F — сила, приложенная к тележке
    """
    x, x_dot, th, th_dot = state
    sin_t, cos_t = np.sin(th), np.cos(th)
    den = M + m * sin_t**2

    x_dd = (F + m * sin_t * (L * th_dot**2 + g * cos_t)) / den
    th_dd = (
        -F * cos_t
        - m * L * th_dot**2 * cos_t * sin_t
        - (M + m) * g * sin_t
    ) / (L * den)

    return np.array([x_dot, x_dd, th, th_dd])

# ---------- PD-КОНТРОЛЛЕР ----------
def PD(x, x_dot, th, th_dot):
    th_err = -th
    th_d_err = -th_dot
    x_err = -x
    x_d_err = -x_dot

    F = 60 * th_err + 10 * th_d_err + 2 * x_err + 4 * x_d_err
    return np.clip(F, -50, 50)

# ---------- ОБЩАЯ СИМУЛЯЦИЯ ----------
def simulate(T=10.0, dt=0.01, theta0_deg=8.0):
    """
    Возвращает:
      t     — массив времени
      state — массив Nx4 [x, x_dot, theta, theta_dot]
    """
    N = int(T / dt)
    t = np.linspace(0, T, N)
    state = np.zeros((N, 4))
    state[0] = [0.0, 0.0, np.deg2rad(theta0_deg), 0.0]

    # параметры землетрясения
    quake_start, quake_end = 2.0, 3.5
    quake_amp, quake_freq = 40.0, 5.0

    for i in range(N - 1):
        x, x_dot, th, th_dot = state[i]

        # управление
        F_ctrl = PD(x, x_dot, th, th_dot)

        # землетрясение
        if quake_start < t[i] < quake_end:
            tau = t[i] - quake_start
            F_quake = quake_amp * np.sin(2 * np.pi * quake_freq * tau)
        else:
            F_quake = 0.0

        F = F_ctrl + F_quake
        state[i + 1] = state[i] + dt * dynamics(state[i], F)

    return t, state

# ================== 2D АНИМАЦИЯ ==================
def make_anim_2d(path="/tmp/anim_2d.html"):
    os.makedirs(os.path.dirname(path), exist_ok=True)

    t, state = simulate()
    x = state[:, 0]
    th = state[:, 2]

    bob_x = x + L * np.sin(th)
    bob_y = 0 + L * np.cos(th)

    fig, ax = plt.subplots(figsize=(6, 4))
    ax.set_xlim(-3, 3)
    ax.set_ylim(-1, 2.5)
    ax.set_xlabel("x (м)")
    ax.set_ylabel("y (м)")
    ax.set_title("2D: маятник на тележке (с землетрясением)")
    ax.grid(True, linestyle=":")

    ax.axhline(0, color="black")

    # синяя тележка
    cart_w, cart_h = 0.6, 0.25
    cart = plt.Rectangle(
        (0, 0), cart_w, cart_h,
        facecolor="blue", edgecolor="blue", linewidth=2
    )
    ax.add_patch(cart)

    (rod,) = ax.plot([], [], lw=3, color="black")
    (bob,) = ax.plot([], [], "o", markersize=10, color="orange")

    def init():
        rod.set_data([], [])
        bob.set_data([], [])
        return rod, bob, cart

    def update(i):
        cx = x[i] - cart_w / 2
        cart.set_xy((cx, -cart_h / 2))

        px, py = x[i], 0.0
        rod.set_data([px, bob_x[i]], [py, bob_y[i]])
        bob.set_data([bob_x[i]], [bob_y[i]])
        return rod, bob, cart

    anim = FuncAnimation(
        fig, update,
        frames=range(0, len(t), 3),
        init_func=init,
        interval=20
    )

    html = anim.to_jshtml()
    plt.close(fig)

    with open(path, "w", encoding="utf-8") as f:
        f.write(html)

    return path

# ================== ВСПОМОГАТЕЛЬНОЕ ДЛЯ 3D ==================
def make_cart_vertices(cx, cy=0.0, base_z=0.0,
                       cart_w=0.6, cart_d=0.5, cart_h=0.25):
    x0 = cx - cart_w / 2
    x1 = cx + cart_w / 2
    y0 = cy - cart_d / 2
    y1 = cy + cart_d / 2
    z0 = base_z
    z1 = base_z + cart_h

    v = np.array([
        [x0, y0, z0],
        [x1, y0, z0],
        [x1, y1, z0],
        [x0, y1, z0],
        [x0, y0, z1],
        [x1, y0, z1],
        [x1, y1, z1],
        [x0, y1, z1],
    ])

    faces = [
        [v[0], v[1], v[2], v[3]],
        [v[4], v[5], v[6], v[7]],
        [v[0], v[1], v[5], v[4]],
        [v[1], v[2], v[6], v[5]],
        [v[2], v[3], v[7], v[6]],
        [v[3], v[0], v[4], v[7]],
    ]
    return faces

def set_equal_aspect_3d(ax):
    xr = ax.get_xlim3d()
    yr = ax.get_ylim3d()
    zr = ax.get_zlim3d()
    x_mid = 0.5 * (xr[0] + xr[1])
    y_mid = 0.5 * (yr[0] + yr[1])
    z_mid = 0.5 * (zr[0] + zr[1])
    max_range = max(xr[1] - xr[0], yr[1] - yr[0], zr[1] - zr[0])
    r = 0.5 * max_range
    ax.set_xlim3d([x_mid - r, x_mid + r])
    ax.set_ylim3d([y_mid - r, y_mid + r])
    ax.set_zlim3d([z_mid - r, z_mid + r])

# ================== 3D АНИМАЦИЯ ==================
def make_anim_3d(path="/tmp/anim_3d.html"):
    os.makedirs(os.path.dirname(path), exist_ok=True)

    t, state = simulate()
    x = state[:, 0]
    th = state[:, 2]

    pivot_x = x
    pivot_y = np.zeros_like(x)
    pivot_z = np.zeros_like(x)

    bob_x = pivot_x + L * np.sin(th)
    bob_y = np.zeros_like(x)
    bob_z = pivot_z + L * np.cos(th)

    fig = plt.figure(figsize=(7, 5))
    ax = fig.add_subplot(111, projection="3d")

    x_min, x_max = -3, 3
    y_min, y_max = -1, 1
    z_min, z_max = -0.5, 2.0

    ax.set_xlim(x_min, x_max)
    ax.set_ylim(y_min, y_max)
    ax.set_zlim(z_min, z_max)

    ax.set_xlabel("X (м)")
    ax.set_ylabel("Y (м)")
    ax.set_zlabel("Z (м)")
    ax.set_title("3D: маятник на тележке (с землетрясением)")

    ax.plot([x_min, x_max], [0, 0], [0, 0], color="black")

    cart_w, cart_d, cart_h = 0.6, 0.5, 0.25
    faces0 = make_cart_vertices(x[0], 0.0, 0.0, cart_w, cart_d, cart_h)

    cart_poly = Poly3DCollection(
        faces0,
        facecolors="blue",
        edgecolors="blue",
        alpha=0.9
    )
    ax.add_collection3d(cart_poly)

    (rod,) = ax.plot([], [], [], lw=3, color="black")
    (bob,) = ax.plot([], [], [], "o", color="orange", markersize=8)

    set_equal_aspect_3d(ax)

    def init():
        rod.set_data([], [])
        rod.set_3d_properties([])
        bob.set_data([], [])
        bob.set_3d_properties([])
        return rod, bob, cart_poly

    def update(i):
        faces = make_cart_vertices(x[i], 0.0, 0.0, cart_w, cart_d, cart_h)
        cart_poly.set_verts(faces)

        px, py, pz = pivot_x[i], pivot_y[i], pivot_z[i] + cart_h
        bx, by, bz = bob_x[i], bob_y[i], bob_z[i] + cart_h

        rod.set_data([px, bx], [py, by])
        rod.set_3d_properties([pz, bz])

        bob.set_data([bx], [by])
        bob.set_3d_properties([bz])

        return rod, bob, cart_poly

    anim = FuncAnimation(
        fig, update,
        frames=range(0, len(t), 3),
        init_func=init,
        interval=20
    )

    html = anim.to_jshtml()
    plt.close(fig)

    with open(path, "w", encoding="utf-8") as f:
        f.write(html)

    return path

# ================== FASTAPI СЕРВЕР ==================
app = FastAPI()

@app.get("/", response_class=PlainTextResponse)
def root():
    return "Доступно:\n  /anim/2d  - 2D-анимация\n  /anim/3d  - 3D-анимация\n"

@app.get("/anim/2d")
def api_anim_2d():
    path = make_anim_2d()
    return FileResponse(path, media_type="text/html")

@app.get("/anim/3d")
def api_anim_3d():
    path = make_anim_3d()
    return FileResponse(path, media_type="text/html")

nest_asyncio.apply()

def start_server():
    uvicorn.run(app, host="0.0.0.0", port=8000, log_level="warning")

# запускаем сервер в отдельном потоке
if "server_thread" not in globals():
    server_thread = threading.Thread(target=start_server, daemon=True)
    server_thread.start()
    print("✅ FastAPI сервер запущен на порту 8000")
else:
    print("Сервер уже запущен")

# ================== ПРИМЕР ЗАПРОСА К API (2D) ==================
try:
    r = requests.get("http://127.0.0.1:8000/anim/2d")
    open("from_api_2d.html", "wb").write(r.content)
    display(HTML(open("from_api_2d.html", encoding="utf-8").read()))
    print("✅ 2D-анимация получена по API и показана выше")
except Exception as e:
    print("Ошибка при запросе 2D-анимации по API:", e)

# Если хочешь сразу и 3D из этого же блока — раскомментируй строки ниже:
# try:
#     r = requests.get("http://127.0.0.1:8000/anim/3d")
#     open("from_api_3d.html", "wb").write(r.content)
#     display(HTML(open("from_api_3d.html", encoding="utf-8").read()))
#     print("✅ 3D-анимация получена по API и показана выше")
# except Exception as e:
#     print("Ошибка при запросе 3D-анимации по API:", e)

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from IPython.display import HTML, display
import os

# ================== ПАРАМЕТРЫ СИСТЕМЫ ==================
M = 1.0   # масса тележки
m = 0.1   # масса маятника
L = 0.5   # длина стержня
g = 9.81  # гравитация

# ---------- ДИНАМИКА ----------
def dynamics(state, F):
    """
    state = [x, x_dot, theta, theta_dot]
    F — сила, приложенная к тележке
    """
    x, x_dot, th, th_dot = state
    sin_t, cos_t = np.sin(th), np.cos(th)
    den = M + m * sin_t**2

    x_dd = (F + m * sin_t * (L * th_dot**2 + g * cos_t)) / den
    th_dd = (
        -F * cos_t
        - m * L * th_dot**2 * cos_t * sin_t
        - (M + m) * g * sin_t
    ) / (L * den)

    return np.array([x_dot, x_dd, th, th_dd])

# ---------- PD-КОНТРОЛЛЕР ----------
def PD(x, x_dot, th, th_dot):
    th_err = -th
    th_d_err = -th_dot
    x_err = -x
    x_d_err = -x_dot

    F = 60 * th_err + 10 * th_d_err + 2 * x_err + 4 * x_d_err
    return np.clip(F, -50, 50)

# ---------- ОБЩАЯ СИМУЛЯЦИЯ ----------
def simulate(T=10.0, dt=0.01, theta0_deg=8.0):
    """
    Возвращает:
      t     — массив времени
      state — массив Nx4 [x, x_dot, theta, theta_dot]
    """
    N = int(T / dt)
    t = np.linspace(0, T, N)
    state = np.zeros((N, 4))
    state[0] = [0.0, 0.0, np.deg2rad(theta0_deg), 0.0]

    # параметры землетрясения
    quake_start, quake_end = 2.0, 3.5
    quake_amp, quake_freq = 40.0, 5.0

    for i in range(N - 1):
        x, x_dot, th, th_dot = state[i]

        # управление
        F_ctrl = PD(x, x_dot, th, th_dot)

        # землетрясение
        if quake_start < t[i] < quake_end:
            tau = t[i] - quake_start
            F_quake = quake_amp * np.sin(2 * np.pi * quake_freq * tau)
        else:
            F_quake = 0.0

        F = F_ctrl + F_quake
        state[i + 1] = state[i] + dt * dynamics(state[i], F)

    return t, state

# ================== 2D АНИМАЦИЯ ==================
def make_anim_2d_html():
    t, state = simulate()
    x = state[:, 0]
    th = state[:, 2]

    bob_x = x + L * np.sin(th)
    bob_y = 0 + L * np.cos(th)

    fig, ax = plt.subplots(figsize=(6, 4))
    ax.set_xlim(-3, 3)
    ax.set_ylim(-1, 2.5)
    ax.set_xlabel("x (м)")
    ax.set_ylabel("y (м)")
    ax.set_title("2D: маятник на тележке (с землетрясением)")
    ax.grid(True, linestyle=":")

    ax.axhline(0, color="black")

    # синяя тележка
    cart_w, cart_h = 0.6, 0.25
    cart = plt.Rectangle(
        (0, 0), cart_w, cart_h,
        facecolor="blue", edgecolor="blue", linewidth=2
    )
    ax.add_patch(cart)

    (rod,) = ax.plot([], [], lw=3, color="black")
    (bob,) = ax.plot([], [], "o", markersize=10, color="orange")

    def init():
        rod.set_data([], [])
        bob.set_data([], [])
        return rod, bob, cart

    def update(i):
        cx = x[i] - cart_w / 2
        cart.set_xy((cx, -cart_h / 2))

        px, py = x[i], 0.0
        rod.set_data([px, bob_x[i]], [py, bob_y[i]])
        bob.set_data([bob_x[i]], [bob_y[i]])
        return rod, bob, cart

    anim = FuncAnimation(
        fig, update,
        frames=range(0, len(t), 3),
        init_func=init,
        interval=20
    )

    html = anim.to_jshtml()
    plt.close(fig)
    return html

# ================== ВСПОМОГАТЕЛЬНОЕ ДЛЯ 3D ==================
def make_cart_vertices(cx, cy=0.0, base_z=0.0,
                       cart_w=0.6, cart_d=0.5, cart_h=0.25):
    x0 = cx - cart_w / 2
    x1 = cx + cart_w / 2
    y0 = cy - cart_d / 2
    y1 = cy + cart_d / 2
    z0 = base_z
    z1 = base_z + cart_h

    v = np.array([
        [x0, y0, z0],
        [x1, y0, z0],
        [x1, y1, z0],
        [x0, y1, z0],
        [x0, y0, z1],
        [x1, y0, z1],
        [x1, y1, z1],
        [x0, y1, z1],
    ])

    faces = [
        [v[0], v[1], v[2], v[3]],
        [v[4], v[5], v[6], v[7]],
        [v[0], v[1], v[5], v[4]],
        [v[1], v[2], v[6], v[5]],
        [v[2], v[3], v[7], v[6]],
        [v[3], v[0], v[4], v[7]],
    ]
    return faces

def set_equal_aspect_3d(ax):
    xr = ax.get_xlim3d()
    yr = ax.get_ylim3d()
    zr = ax.get_zlim3d()
    x_mid = 0.5 * (xr[0] + xr[1])
    y_mid = 0.5 * (yr[0] + yr[1])
    z_mid = 0.5 * (zr[0] + zr[1])
    max_range = max(xr[1] - xr[0], yr[1] - yr[0], zr[1] - zr[0])
    r = 0.5 * max_range
    ax.set_xlim3d([x_mid - r, x_mid + r])
    ax.set_ylim3d([y_mid - r, y_mid + r])
    ax.set_zlim3d([z_mid - r, z_mid + r])

# ================== 3D АНИМАЦИЯ ==================
def make_anim_3d_html():
    t, state = simulate()
    x = state[:, 0]
    th = state[:, 2]

    pivot_x = x
    pivot_y = np.zeros_like(x)
    pivot_z = np.zeros_like(x)

    bob_x = pivot_x + L * np.sin(th)
    bob_y = np.zeros_like(x)
    bob_z = pivot_z + L * np.cos(th)

    fig = plt.figure(figsize=(7, 5))
    ax = fig.add_subplot(111, projection="3d")

    x_min, x_max = -3, 3
    y_min, y_max = -1, 1
    z_min, z_max = -0.5, 2.0

    ax.set_xlim(x_min, x_max)
    ax.set_ylim(y_min, y_max)
    ax.set_zlim(z_min, z_max)

    ax.set_xlabel("X (м)")
    ax.set_ylabel("Y (м)")
    ax.set_zlabel("Z (м)")
    ax.set_title("3D: маятник на тележке (с землетрясением)")

    ax.plot([x_min, x_max], [0, 0], [0, 0], color="black")

    cart_w, cart_d, cart_h = 0.6, 0.5, 0.25
    faces0 = make_cart_vertices(x[0], 0.0, 0.0, cart_w, cart_d, cart_h)

    cart_poly = Poly3DCollection(
        faces0,
        facecolors="blue",
        edgecolors="blue",
        alpha=0.9
    )
    ax.add_collection3d(cart_poly)

    (rod,) = ax.plot([], [], [], lw=3, color="black")
    (bob,) = ax.plot([], [], [], "o", color="orange", markersize=8)

    set_equal_aspect_3d(ax)

    def init():
        rod.set_data([], [])
        rod.set_3d_properties([])
        bob.set_data([], [])
        bob.set_3d_properties([])
        return rod, bob, cart_poly

    def update(i):
        faces = make_cart_vertices(x[i], 0.0, 0.0, cart_w, cart_d, cart_h)
        cart_poly.set_verts(faces)

        px, py, pz = pivot_x[i], pivot_y[i], pivot_z[i] + cart_h
        bx, by, bz = bob_x[i], bob_y[i], bob_z[i] + cart_h

        rod.set_data([px, bx], [py, by])
        rod.set_3d_properties([pz, bz])

        bob.set_data([bx], [by])
        bob.set_3d_properties([bz])

        return rod, bob, cart_poly

    anim = FuncAnimation(
        fig, update,
        frames=range(0, len(t), 3),
        init_func=init,
        interval=20
    )

    html = anim.to_jshtml()
    plt.close(fig)
    return html

# ================== "API"-ФУНКЦИИ ДЛЯ ВЫЗОВА ==================
def get_anim_2d():
    """API: вернуть и показать 2D-анимацию."""
    html = make_anim_2d_html()
    display(HTML(html))

def get_anim_3d():
    """API: вернуть и показать 3D-анимацию."""
    html = make_anim_3d_html()
    display(HTML(html))

print("✅ Код загружен. Доступные функции: get_anim_2d(), get_anim_3d()")

get_anim_2d()

get_anim_3d()

# -*- coding: utf-8 -*-
# Cart-Pole (тележка + перевёрнутый маятник)
# ✅ Нормальная геометрия (aspect='equal')
# ✅ Траектория верхней точки (груза) + траектория точки крепления
# ✅ CASCADE: PID не пересоздаётся каждый шаг
# ✅ Телеметрия: значения строчками с подписями и единицами
# ✅ Экспорт видео (MP4/GIF) + автоматическое скачивание в Google Colab

import os
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import HTML, display
import ipywidgets as widgets
from scipy.linalg import solve_continuous_are
from ipywidgets import Accordion

# ---------- ПАРАМЕТРЫ СИСТЕМЫ ----------
M = 1.0
m = 0.2
L = 1.0
g = 9.81
mu = 0.05

def cart_pole_dynamics(state, F):
    """
    state = [x, x_dot, theta, theta_dot]
    theta=0 -> маятник вертикально вверх (стабилизация вокруг 0)
    """
    x, x_dot, theta, theta_dot = state
    sin_th = np.sin(theta)
    cos_th = np.cos(theta)

    total_mass = M + m
    temp = (F + m * L * theta_dot**2 * sin_th - mu * x_dot) / total_mass

    theta_ddot = (g * sin_th - cos_th * temp) / (
        L * (4.0/3.0 - m * cos_th**2 / total_mass)
    )
    x_ddot = temp - m * L * theta_ddot * cos_th / total_mass

    return np.array([x_dot, x_ddot, theta_dot, theta_ddot])

def linearized_system_matrices():
    total_mass = M + m
    A = np.array([
        [0, 1, 0, 0],
        [0, -mu/total_mass, -m*g/total_mass, 0],
        [0, 0, 0, 1],
        [0, -mu/(L*total_mass), (M+m)*g/(L*total_mass), 0]
    ])
    B = np.array([
        [0],
        [1/total_mass],
        [0],
        [1/(L*total_mass)]
    ])
    return A, B

def compute_lqr_gain(Q_diag, R_val):
    A, B = linearized_system_matrices()
    Q = np.diag(Q_diag)
    R = np.array([[R_val]])
    try:
        P = solve_continuous_are(A, B, Q, R)
        K = np.linalg.inv(R) @ B.T @ P
        return K.flatten(), True
    except Exception:
        print("LQR решение не найдено, используем эвристические коэффициенты")
        return np.array([-2.0, -3.0, -50.0, -10.0]), False

def angle_wrap(theta):
    return (theta + np.pi) % (2*np.pi) - np.pi

# ---------- КОНТРОЛЛЕРЫ ----------
class PIDController:
    """PID: возвращает u и разложение на P/I/D"""
    def __init__(self, Kp, Ki, Kd, max_output, dt, integral_limit=None):
        self.Kp = Kp
        self.Ki = Ki
        self.Kd = Kd
        self.max_output = max_output
        self.dt = dt
        self.integral = 0.0
        self.prev_error = 0.0
        self.integral_limit = integral_limit

    def reset(self):
        self.integral = 0.0
        self.prev_error = 0.0

    def update(self, error):
        self.integral += error * self.dt
        if self.integral_limit is not None:
            self.integral = np.clip(self.integral, -self.integral_limit, self.integral_limit)

        derivative = (error - self.prev_error) / self.dt if self.dt > 0 else 0.0
        self.prev_error = error

        P = self.Kp * error
        I = self.Ki * self.integral
        D = self.Kd * derivative
        u = P + I + D
        u_sat = float(np.clip(u, -self.max_output, self.max_output))

        # простой anti-windup
        if u != u_sat and self.Ki != 0:
            self.integral *= 0.98

        return u_sat, P, I, D, self.integral

def controller_PD(x, x_dot, theta, theta_dot,
                  x_ref, theta_ref,
                  Kp_theta, Kd_theta, Kp_x, Kd_x, F_max):
    e_theta = angle_wrap(theta_ref - theta)
    e_x = x_ref - x
    F = (Kp_theta * e_theta +
         Kd_theta * (0.0 - theta_dot) +
         Kp_x * e_x +
         Kd_x * (0.0 - x_dot))
    return float(np.clip(F, -F_max, F_max))

def controller_DOG(x, x_dot, theta, theta_dot,
                   x_ref, theta_ref,
                   Kp_theta, Kd_theta, Kp_x, Kd_x, F_max):
    e_theta = angle_wrap(theta_ref - theta)
    e_x = x_ref - x
    F = (Kp_theta * np.tanh(2.0 * e_theta) +
         Kd_theta * np.tanh(-theta_dot/2.0) +
         Kp_x * np.tanh(e_x/5.0) +
         Kd_x * np.tanh(-x_dot/2.0))
    return float(np.clip(F, -F_max, F_max))

def controller_LQR(x, x_dot, theta, theta_dot,
                   x_ref, theta_ref, K, F_max):
    theta_error = angle_wrap(theta_ref - theta)
    x_error = x_ref - x
    state_error = np.array([x_error, -x_dot, theta_error, -theta_dot])
    F = -np.dot(K, state_error)
    return float(np.clip(F, -F_max, F_max))

# ---------- СИМУЛЯЦИЯ + ВИЗУАЛИЗАЦИЯ ----------
def simulate_and_plot_cart_pole(
    mode='CASCADE',
    x_ref=5.0,
    theta_ref_deg=0.0,
    x0=0.0,
    xdot0=0.0,
    theta0_deg=10.0,
    thetadot0=0.0,
    Kp_theta=80.0,
    Kd_theta=15.0,
    Kp_x=1.5,
    Kd_x=3.0,
    F_max=100.0,
    # LQR
    Q_xx=0.5,
    Q_xd=0.05,
    Q_theta=300.0,
    Q_thetad=20.0,
    R_val=0.1,
    # PID позиции
    pos_Kp=0.5,
    pos_Ki=0.05,
    pos_Kd=1.0,
    T=20.0,
    dt=0.01,
    show_animation=True,
    track_length=20.0,
    # экспорт
    save_video=False,
    video_format='mp4',      # 'mp4' или 'gif'
    video_filename='cartpole',
    video_fps=30
):
    plt.close('all')

    theta_ref = np.deg2rad(theta_ref_deg)
    theta0 = np.deg2rad(theta0_deg)

    N = int(T / dt)
    t = np.linspace(0, T, N)

    state = np.zeros((N, 4))
    state[0] = [x0, xdot0, theta0, thetadot0]
    F_arr = np.zeros(N)

    theta_desired_arr = np.zeros(N)
    pid_P_arr = np.zeros(N)
    pid_I_arr = np.zeros(N)
    pid_D_arr = np.zeros(N)
    pid_u_arr = np.zeros(N)
    pid_int_arr = np.zeros(N)

    # LQR
    K_lqr = None
    if mode in ['LQR', 'CASCADE']:
        Q_diag = [Q_xx, Q_xd, Q_theta, Q_thetad]
        K_lqr, success = compute_lqr_gain(Q_diag, R_val)
        if success:
            print(f"LQR K = [{K_lqr[0]:.3f}, {K_lqr[1]:.3f}, {K_lqr[2]:.3f}, {K_lqr[3]:.3f}]")
        else:
            print(f"Эвристический K = [{K_lqr[0]:.3f}, {K_lqr[1]:.3f}, {K_lqr[2]:.3f}, {K_lqr[3]:.3f}]")

    # PID создаём один раз
    pos_pid = None
    if mode == 'CASCADE':
        pos_pid = PIDController(
            pos_Kp, pos_Ki, pos_Kd,
            max_output=np.deg2rad(30),
            dt=dt,
            integral_limit=50.0
        )

    for k in range(N - 1):
        x, x_dot, theta, theta_dot = state[k]

        if mode == 'Off':
            F = 0.0

        elif mode == 'PD':
            F = controller_PD(x, x_dot, theta, theta_dot, x_ref, theta_ref,
                              Kp_theta, Kd_theta, Kp_x, Kd_x, F_max)

        elif mode == 'Dog':
            F = controller_DOG(x, x_dot, theta, theta_dot, x_ref, theta_ref,
                               Kp_theta, Kd_theta, Kp_x, Kd_x, F_max)

        elif mode == 'LQR':
            F = controller_LQR(x, x_dot, theta, theta_dot, x_ref, theta_ref, K_lqr, F_max)

        elif mode == 'CASCADE':
            e_x = x_ref - x
            u_pid, P, I, D, integ = pos_pid.update(e_x)
            theta_desired = float(np.clip(u_pid, np.deg2rad(-30), np.deg2rad(30)))

            theta_desired_arr[k] = theta_desired
            pid_u_arr[k] = u_pid
            pid_P_arr[k] = P
            pid_I_arr[k] = I
            pid_D_arr[k] = D
            pid_int_arr[k] = integ

            if K_lqr is not None:
                F = controller_LQR(x, x_dot, theta, theta_dot, x_ref, theta_desired, K_lqr, F_max)
            else:
                F = controller_PD(x, x_dot, theta, theta_dot, x_ref, theta_desired,
                                  Kp_theta, Kd_theta, 0, 0, F_max)
        else:
            F = 0.0

        F_arr[k] = F
        state[k+1] = state[k] + dt * cart_pole_dynamics(state[k], F)

    x = state[:, 0]
    theta = state[:, 2]
    theta_dot = state[:, 3]

    # ---------- ГРАФИКИ ----------
    if mode == 'CASCADE':
        fig1, ax = plt.subplots(5, 1, figsize=(11, 12), sharex=True)
    else:
        fig1, ax = plt.subplots(4, 1, figsize=(11, 10), sharex=True)

    ax[0].plot(t, x, label='x(t)', linewidth=2)
    ax[0].axhline(x_ref, linestyle='--', color='k', label='x_ref', linewidth=2)
    ax[0].axhline(track_length/2, linestyle=':', color='gray', alpha=0.5)
    ax[0].axhline(-track_length/2, linestyle=':', color='gray', alpha=0.5)
    ax[0].fill_between(t, -track_length/2, track_length/2, alpha=0.08)
    ax[0].set_ylabel("x, м")
    ax[0].grid(True, alpha=0.3)
    ax[0].legend(loc='upper right')
    ax[0].set_ylim(-track_length/2-1, track_length/2+1)

    ax[1].plot(t, np.rad2deg(theta), label='θ(t)', linewidth=2)
    ax[1].axhline(theta_ref_deg, linestyle='--', color='k', label='θ_ref', linewidth=2)
    if mode == 'CASCADE':
        ax[1].plot(t, np.rad2deg(theta_desired_arr), '--', label='θ_desired', alpha=0.8)
    ax[1].axhline(30, linestyle=':', alpha=0.5)
    ax[1].axhline(-30, linestyle=':', alpha=0.5)
    ax[1].set_ylabel("θ, °")
    ax[1].grid(True, alpha=0.3)
    ax[1].legend(loc='upper right')
    ax[1].set_ylim(-45, 45)

    ax[2].plot(t, F_arr, label='F(t)', linewidth=2)
    ax[2].axhline(F_max, linestyle='--', linewidth=1, alpha=0.7, label='±F_max')
    ax[2].axhline(-F_max, linestyle='--', linewidth=1, alpha=0.7)
    ax[2].fill_between(t, -F_max, F_max, alpha=0.08)
    ax[2].set_ylabel("F, Н")
    ax[2].grid(True, alpha=0.3)
    ax[2].legend(loc='upper right')

    ax[3].plot(t, state[:, 1], label='x_dot', linewidth=1.5)
    ax[3].plot(t, state[:, 3], label='theta_dot', linewidth=1.5)
    ax[3].set_ylabel("скорости")
    ax[3].grid(True, alpha=0.3)
    ax[3].legend(loc='upper right')
    ax[-1].set_xlabel("t, c")

    if mode == 'CASCADE':
        ax[4].plot(t, pid_P_arr, label='PID P', linewidth=1.5)
        ax[4].plot(t, pid_I_arr, label='PID I', linewidth=1.5)
        ax[4].plot(t, pid_D_arr, label='PID D', linewidth=1.5)
        ax[4].plot(t, pid_u_arr, label='PID u (до clip)', linewidth=1.0, alpha=0.7)
        ax[4].set_ylabel("PID (рад)")
        ax[4].grid(True, alpha=0.3)
        ax[4].legend(loc='upper right')

    fig1.suptitle(f"Cart-Pole | mode={mode} | x_ref={x_ref} м | track={track_length} м")
    plt.tight_layout()
    plt.show()

    # ---------- АНИМАЦИЯ + СОХРАНЕНИЕ ----------
    if show_animation:
        fig, axa = plt.subplots(figsize=(12, 6))

        x_min_view = min(np.min(x) - 3.0, -track_length/2 - 2.0)
        x_max_view = max(np.max(x) + 3.0,  track_length/2 + 2.0)

        axa.set_xlim(x_min_view, x_max_view)
        axa.set_ylim(-1.5, 3.0)
        axa.set_xlabel("x, м")
        axa.set_ylabel("y, м")
        axa.set_aspect('equal', adjustable='box')

        axa.axhline(0, color="black", linewidth=2)
        axa.axvline(-track_length/2, color='black', linewidth=3)
        axa.axvline(track_length/2, color='black', linewidth=3)
        axa.grid(True, linestyle=":", linewidth=0.5, alpha=0.5)
        axa.set_title(f"Перевёрнутый маятник | {mode} | трек ±{track_length/2} м")

        cart_w, cart_h = 1.5, 0.8
        cart = plt.Rectangle((0, 0), cart_w, cart_h, fc="blue", ec="blue", linewidth=2, alpha=0.9)
        axa.add_patch(cart)

        rod, = axa.plot([], [], lw=4, color='black', alpha=0.9)
        bob, = axa.plot([], [], 'o', color='orange', markersize=10)

        top_traj, = axa.plot([], [], '-', color='orange', linewidth=1.5, alpha=0.55)
        pivot_traj, = axa.plot([], [], '-', color='black', linewidth=1.0, alpha=0.25)

        target_line = axa.axvline(x_ref, color='green', linestyle='--', linewidth=2, alpha=0.8)

        text_box = axa.text(
            0.02, 0.98, "",
            fontsize=10, va="top", transform=axa.transAxes,
            bbox=dict(boxstyle="round", facecolor="white", alpha=0.92)
        )

        def pivot_xy(xi):
            cart_y = -cart_h/2
            pivot_y = cart_y + cart_h/2  # верх тележки -> 0
            return xi, pivot_y

        def top_xy(xi, th):
            px, py = pivot_xy(xi)
            return px + L*np.sin(th), py + L*np.cos(th)

        step = max(1, int(0.02 / dt))
        frame_idx = np.arange(0, N, step)

        def init():
            rod.set_data([], [])
            bob.set_data([], [])
            top_traj.set_data([], [])
            pivot_traj.set_data([], [])
            text_box.set_text("")
            return rod, bob, cart, top_traj, pivot_traj, target_line, text_box

        def update(frame_number):
            k = frame_idx[frame_number]
            xi = x[k]
            th = theta[k]

            cart_x = xi - cart_w/2
            cart_y = -cart_h/2
            cart.set_xy((cart_x, cart_y))

            px, py = pivot_xy(xi)
            bx, by = top_xy(xi, th)

            rod.set_data([px, bx], [py, by])
            bob.set_data([bx], [by])

            start = max(0, k - 250*step)
            xs = x[start:k+1]
            ths = theta[start:k+1]

            piv_x = xs
            piv_y = np.zeros_like(xs)  # верх тележки y=0
            pivot_traj.set_data(piv_x, piv_y)

            top_x = piv_x + L*np.sin(ths)
            top_y = piv_y + L*np.cos(ths)
            top_traj.set_data(top_x, top_y)

            target_line.set_xdata([x_ref, x_ref])

            angle_err_deg_abs = abs(np.rad2deg(angle_wrap(th - theta_ref)))
            pos_err_abs = abs(xi - x_ref)
            if angle_err_deg_abs < 5.0 and pos_err_abs < 0.5 and abs(theta_dot[k]) < 0.5:
                status = "СТАБИЛЬНО ✓"
            elif angle_err_deg_abs < 15.0:
                status = "СТАБИЛИЗИРУЕТСЯ"
            else:
                status = "НЕСТАБИЛЬНО"

            theta_err_deg_signed = np.rad2deg(angle_wrap(th - theta_ref))

            lines = [
                "СОСТОЯНИЕ СИСТЕМЫ",
                "-------------------------",
                f"t      : {t[k]:6.2f}  с        (время)",
                "",
                f"x      : {xi:+6.2f}  м        (позиция тележки)",
                f"x_err  : {xi-x_ref:+6.2f}  м        (ошибка позиции)",
                f"x_dot  : {state[k,1]:+6.2f}  м/с      (скорость тележки)",
                "",
                f"θ      : {np.rad2deg(th):+6.2f}  °        (угол маятника)",
                f"θ_err  : {theta_err_deg_signed:+6.2f}  °        (ошибка угла, со знаком)",
                f"θ_dot  : {theta_dot[k]:+6.2f}  рад/с    (угловая скорость)",
                "",
                f"F      : {F_arr[k]:+6.1f}  Н        (управляющая сила)",
                "",
                f"СТАТУС : {status}",
            ]

            if mode == 'CASCADE':
                lines += [
                    "",
                    "PID РЕГУЛЯТОР ПОЗИЦИИ",
                    "-------------------------",
                    f"P      : {pid_P_arr[k]:+7.4f}  рад      (пропорц.)",
                    f"I      : {pid_I_arr[k]:+7.4f}  рад      (интеграл)",
                    f"D      : {pid_D_arr[k]:+7.4f}  рад      (производн.)",
                    f"∫e dt  : {pid_int_arr[k]:+7.3f}          (инт. ошибка)",
                    "",
                    f"θ_des  : {np.rad2deg(theta_desired_arr[k]):+6.2f}  °        (заданный угол)"
                ]

            text_box.set_text("\n".join(lines))
            return rod, bob, cart, top_traj, pivot_traj, target_line, text_box

        anim = FuncAnimation(
            fig, update, init_func=init,
            frames=len(frame_idx),
            interval=1000 * dt * step,
            blit=True
        )

        # показать в ноутбуке
        plt.close(fig)
        display(HTML(anim.to_jshtml()))

        # ---- сохранить и скачать ----
        if save_video:
            out_name = f"{video_filename}.{video_format}".replace("..", ".")
            out_path = os.path.abspath(out_name)

            print(f"\nСохраняю видео: {out_path}")

            if video_format.lower() == 'mp4':
                # mp4 через ffmpeg
                import subprocess
                try:
                    subprocess.run(["bash", "-lc", "ffmpeg -version"], check=True, capture_output=True)
                except Exception:
                    subprocess.run(["bash", "-lc", "apt-get -y update && apt-get -y install ffmpeg"], check=True)

                from matplotlib.animation import FFMpegWriter
                writer = FFMpegWriter(fps=int(video_fps), bitrate=1800)
                anim.save(out_path, writer=writer)

            elif video_format.lower() == 'gif':
                from matplotlib.animation import PillowWriter
                writer = PillowWriter(fps=int(video_fps))
                anim.save(out_path, writer=writer)
            else:
                raise ValueError("video_format должен быть 'mp4' или 'gif'")

            print("Готово. Начинаю скачивание...")
            from google.colab import files
            files.download(out_path)

    # ---------- СТАТИСТИКА ----------
    print(f"\n{'='*60}")
    print(f"СТАТИСТИКА ({mode}) | трек ±{track_length/2} м | цель {x_ref} м")
    print(f"{'='*60}")
    print(f"Макс |θ|: {np.max(np.abs(np.rad2deg(theta))):.1f}°")
    print(f"Макс |F|: {np.max(np.abs(F_arr)):.1f} Н")
    print(f"Макс |x_dot|: {np.max(np.abs(state[:,1])):.2f} м/с")
    print(f"Путь: {np.sum(np.abs(np.diff(x))):.1f} м")
    final_pos_error = abs(x[-1] - x_ref)
    final_angle_error = abs(np.rad2deg(angle_wrap(theta[-1] - theta_ref)))
    print(f"Финальная ошибка: x={final_pos_error:.3f} м, θ={final_angle_error:.2f}°")
    if mode != 'Off':
        IAE_angle = np.trapz(np.abs(theta), t)
        IAE_position = np.trapz(np.abs(x - x_ref), t)
        print(f"IAE(угол): {IAE_angle:.2f} рад·с | IAE(позиция): {IAE_position:.2f} м·с")


# ---------- ВИДЖЕТЫ ДЛЯ COLAB ----------
mode_widget = widgets.Dropdown(
    options=[('Off','Off'),
             ('PD','PD'),
             ('Dog (пастушья)','Dog'),
             ('LQR','LQR'),
             ('Каскадный (рекомендуется)','CASCADE')],
    value='CASCADE',
    description='Режим:'
)

x_ref_widget = widgets.FloatSlider(value=5.0, min=-10, max=10, step=0.5,
                                   description='x_ref (м):', continuous_update=False,
                                   style={'description_width': 'initial'})
track_length_widget = widgets.FloatSlider(value=20.0, min=10, max=50, step=5,
                                          description='Длина трека (м):', continuous_update=False,
                                          style={'description_width': 'initial'})
theta_ref_widget = widgets.FloatSlider(value=0.0, min=-30, max=30, step=1,
                                       description='θ_ref (°):', continuous_update=False)

x0_widget = widgets.FloatSlider(value=0.0, min=-5, max=5, step=0.5,
                                description='x0 (м):', continuous_update=False)
xdot0_widget = widgets.FloatSlider(value=0.0, min=-5, max=5, step=0.1,
                                   description='ẋ0 (м/с):', continuous_update=False)

theta0_widget = widgets.FloatSlider(value=15.0, min=-60, max=60, step=5,
                                    description='θ0 (°):', continuous_update=False,
                                    style={'description_width': 'initial'})
thetadot0_widget = widgets.FloatSlider(value=0.0, min=-10, max=10, step=0.1,
                                       description='θ̇0 (рад/с):', continuous_update=False)

Kp_theta_widget = widgets.FloatSlider(value=80.0, min=10, max=200, step=5,
                                      description='Kθ_p:', continuous_update=False)
Kd_theta_widget = widgets.FloatSlider(value=15.0, min=1, max=50, step=1,
                                      description='Kθ_d:', continuous_update=False)

Kp_x_widget = widgets.FloatSlider(value=1.5, min=0.1, max=5.0, step=0.1,
                                  description='Kx_p:', continuous_update=False)
Kd_x_widget = widgets.FloatSlider(value=3.0, min=0.1, max=10.0, step=0.1,
                                  description='Kx_d:', continuous_update=False)

Q_xx_widget = widgets.FloatSlider(value=0.5, min=0.1, max=5.0, step=0.1,
                                  description='Q_xx:', continuous_update=False)
Q_xd_widget = widgets.FloatSlider(value=0.05, min=0.01, max=0.5, step=0.01,
                                  description='Q_xd:', continuous_update=False)
Q_theta_widget = widgets.FloatSlider(value=300.0, min=50, max=1000, step=50,
                                     description='Q_θ:', continuous_update=False)
Q_thetad_widget = widgets.FloatSlider(value=20.0, min=5, max=100, step=5,
                                      description='Q_θd:', continuous_update=False)
R_widget = widgets.FloatSlider(value=0.1, min=0.01, max=1, step=0.01,
                               description='R:', continuous_update=False)

pos_Kp_widget = widgets.FloatSlider(value=0.5, min=0.1, max=2.0, step=0.1,
                                    description='Pos_Kp:', continuous_update=False)
pos_Ki_widget = widgets.FloatSlider(value=0.05, min=0.0, max=0.2, step=0.01,
                                    description='Pos_Ki:', continuous_update=False)
pos_Kd_widget = widgets.FloatSlider(value=1.0, min=0.0, max=5.0, step=0.1,
                                    description='Pos_Kd:', continuous_update=False)

F_max_widget = widgets.FloatSlider(value=100.0, min=20, max=200, step=10,
                                   description='F_max (Н):', continuous_update=False,
                                   style={'description_width': 'initial'})
T_widget = widgets.FloatSlider(value=20.0, min=5, max=60, step=5,
                               description='Время (с):', continuous_update=False)
dt_widget = widgets.FloatLogSlider(value=0.01, base=10, min=-3, max=-1,
                                   description='dt:', continuous_update=False)
show_anim_widget = widgets.Checkbox(value=True, description='Анимация')

# --- экспорт видео ---
save_video_widget = widgets.Checkbox(value=False, description='Сохранить видео и скачать')
video_format_widget = widgets.Dropdown(options=['mp4','gif'], value='mp4', description='Формат:')
video_fps_widget = widgets.IntSlider(value=30, min=10, max=60, step=5, description='FPS:')
video_name_widget = widgets.Text(value='cartpole', description='Имя файла:')

basic_tab = widgets.VBox([
    widgets.HTML("<h4>Основные</h4>"),
    widgets.HBox([x_ref_widget, track_length_widget]),
    widgets.HBox([theta_ref_widget, F_max_widget]),
    widgets.HBox([x0_widget, theta0_widget]),
    widgets.HBox([xdot0_widget, thetadot0_widget]),
    widgets.HBox([T_widget, dt_widget]),
    show_anim_widget,
    widgets.HTML("<hr><b>Экспорт видео</b>"),
    widgets.HBox([save_video_widget, video_format_widget]),
    widgets.HBox([video_fps_widget, video_name_widget]),
])

pd_tab = widgets.VBox([
    widgets.HTML("<h4>PD / Dog</h4>"),
    widgets.HBox([Kp_theta_widget, Kd_theta_widget]),
    widgets.HBox([Kp_x_widget, Kd_x_widget]),
])

lqr_tab = widgets.VBox([
    widgets.HTML("<h4>LQR</h4>"),
    widgets.HBox([Q_xx_widget, Q_xd_widget]),
    widgets.HBox([Q_theta_widget, Q_thetad_widget]),
    R_widget
])

cascade_tab = widgets.VBox([
    widgets.HTML("<h4>CASCADE (PID позиции → θ_des)</h4>"),
    widgets.HBox([pos_Kp_widget, pos_Ki_widget]),
    pos_Kd_widget
])

accordion = Accordion(children=[basic_tab, pd_tab, lqr_tab, cascade_tab])
accordion.set_title(0, 'Основные')
accordion.set_title(1, 'PD/Dog')
accordion.set_title(2, 'LQR')
accordion.set_title(3, 'CASCADE (PID)')

controls = widgets.VBox([mode_widget, widgets.HTML("<hr>"), accordion])

out = widgets.interactive_output(
    simulate_and_plot_cart_pole,
    dict(
        mode=mode_widget,
        x_ref=x_ref_widget,
        theta_ref_deg=theta_ref_widget,
        x0=x0_widget,
        xdot0=xdot0_widget,
        theta0_deg=theta0_widget,
        thetadot0=thetadot0_widget,
        Kp_theta=Kp_theta_widget,
        Kd_theta=Kd_theta_widget,
        Kp_x=Kp_x_widget,
        Kd_x=Kd_x_widget,
        F_max=F_max_widget,
        Q_xx=Q_xx_widget,
        Q_xd=Q_xd_widget,
        Q_theta=Q_theta_widget,
        Q_thetad=Q_thetad_widget,
        R_val=R_widget,
        pos_Kp=pos_Kp_widget,
        pos_Ki=pos_Ki_widget,
        pos_Kd=pos_Kd_widget,
        T=T_widget,
        dt=dt_widget,
        show_animation=show_anim_widget,
        track_length=track_length_widget,
        save_video=save_video_widget,
        video_format=video_format_widget,
        video_filename=video_name_widget,
        video_fps=video_fps_widget
    )
)

display(controls, out)